Condition: union(unionIdentifier = type)?  # TODO
    properties: 
        mode: Mode? ALL # The mode of operation
        otherwise: EffectList?  # A list of effects that will run if this condition is false
        else: EffectList?  # A list of effects that will run if this condition is false
    unions: 
        BIOME: BiomeCondition? { type: BIOME } # Checks if the biome that the user, target entity, or location is in is one of the listed biomes
        BLOCK: BlockCondition? { type: BLOCK } # Checks if the location has one of the listed blocks
        CHANCE: ChanceCondition? { type: CHANCE } # A chance for this condition to be true
        COMPARISON: ComparisonCondition? { type: COMPARISON } # Compares a variable
        COOLDOWN: CooldownCondition? { type: COOLDOWN } # Checks if the time since the get last effect triggered is after the cooldown
        DISTANCE: DistanceCondition? { type: DISTANCE } # Checks if the distance between the user and target entity is in the range
        ENTITY: EntityWhitelistCondition? { type: ENTITY } # Checks the target entity against this whitelist/blacklist
        FLY: FlyingCondition? { type: FLY } # Checks if the user or target entity is flying
        FLYING: FlyingCondition? { type: FLYING } # Checks if the user or target entity is flying
        GLIDING: GlidingCondition? { type: GLIDING } # Checks if the user gliding
        HEALTH: HealthCondition? { type: HEALTH } # Checks if the hp percentage of the user or target entity is in the range
        HEIGHT: HeightCondition? { type: HEIGHT } # Checks if the user or target entity y coordinate is in the range
        HOTBARSLOT: HotbarSlotCondition? { type: HOTBARSLOT } # Checks if the held item/main hand in in a range of hotbar slots
        INBLOCK: InBlockCondition? { type: INBLOCK } # Checks if the user or target entity is in one of the listed blocks
        ININVENTORY: InInventoryCondition? { type: ININVENTORY } # Checks if the user have their inventory GUI opened
        ITEM: ItemCondition? { type: ITEM } # Checks the item or the item in the declared slot against the declared item
        ITEMWRAPPER: ItemWrapperCondition? { type: ITEMWRAPPER } # Checks if all inside conditions are true. \nThe item will be set as the item in the specified slot of the user or target entity
        LIGHT: LightCondition? { type: LIGHT } # Checks the light level
        METADATA: MetadataCondition? { type: METADATA } # Compares a user defined variable
        NOT: NOTCondition? { type: NOT } # Inverts the inside condition
        NPC: NPCCondition? { type: NPC } # Checks if the user or target entity is an npc
        ONGROUND: OnGroundCondition? { type: ONGROUND } # Checks if the user or target entity is on the ground
        OR: ORCondition? { type: OR } # ORs all the conditions inside
        PERMISSION: PermissionCondition? { type: PERMISSION } # Checks whether the user or target entity has the command permission
        POTIONEFFECT: PotionEffectCondition? { type: POTIONEFFECT } # Checks whether the user or target entity has the potion effect
        SHIELDED: ShieldedCondition? { type: SHIELDED } # Checks if the user is blocking
        SHOOTER: ShooterCondition? { type: SHOOTER } # Checks whether the shooter of the `OTHER` entity is the `SELF` entity
        SIZE: SizeCondition? { type: SIZE } # Checks if the size of the user or target entity is in the range (for slimes, magma cubes, and phantoms)
        SNEAK: SneakCondition? { type: SNEAK } # Checks if the player or entity is shifting
        SPEED: SpeedCondition? { type: SPEED } # Checks whether the speed of the user or target entity is in the range
        SPRINTING: SprintingCondition? { type: SPRINTING } # Checks if the user or target entity is sprinting
        SWIMMING: SwimmingCondition? { type: SWIMMING } # Checks if the user or target entity is swimming
        TAMED: TamedCondition? { type: TAMED } # Checks if the target entity is tamed
        TEMPERATURE: TemperatureCondition? { type: TEMPERATURE } # Checks if the location or the location of the user or target entity is in the range
        TIME: TimeCondition? { type: TIME } # Checks the relative in-game time (time of day) of the world that the player is in against the range. Measured in milli-hours or hours*1000
        VISIBILITY: VisibilityCondition? { type: VISIBILITY } # Checks if the user has a direct line of sight to the target entity
        WEATHER: WeatherCondition? { type: WEATHER } # Checks if the world that the user is in has a storm
        WORLD: WorldCondition? { type: WORLD } # Checks if the world that the user, target entity, or location is in is one of the listed worlds
        WRAPPER: WrapperCondition? { type: WRAPPER } # Checks if all inside conditions are true
Effect: union(unionIdentifier = type)!  # 
    properties: 
        mode: Mode? ALL # The mode of operation
    unions: 
        ACTIONBAR: ActionBarEffect? { type: ACTIONBAR } # Sends an action bar to the user or target entity
        AOE: AOE? { type: AOE } # Acts like a trigger. \nTriggers for every entity in the range. \nThe target entity will be set to the entity this trigger triggers for
        ARROW: ArrowEffect? { type: ARROW } # Shoot an arrow to the location of the target entity
        ATTRIBUTE: AttributeEffect? { type: ATTRIBUTE } # Modifies an attribute owned by the user or target entity
        BLOCKENTITY: BlockEntityEffect? { type: BLOCKENTITY } # Change the block at target entity for a duration of time, then change it back. Same as WEB
        BONEMEAL: BonemealEffect? { type: BONEMEAL } # Applies bonemeal to the location or location of the user or target entity
        CANCEL: CancelEffect? { type: CANCEL } # Cancels the event that triggered this effect
        CHANGEHERO: ChangeHeroEffect!  #
        COMMAND: CommandEffect? { type: COMMAND } # Excecutes a list of commands
        DAMAGE: DamageEffect? { type: DAMAGE } # Damages the user or the target entity
        DISGUISE: DisguiseEffect!  #
        FIRE: IgniteEffect? { type: FIRE } # Sets the user or target entity on fire. Same as FIRE
        FLING: VelocityEffect? { type: FLING } # Modifies the velocity of the user or target entity. Same as FLING
        FLY: FlyEffect? { type: FLY } # Sets the ability for the creative flight. Alias for FLYING \n\nModes: \nSELF: For the user;\nOTHER: For the target entity.
        FLYING: FlyEffect? { type: FLYING } # Sets the ability for the creative flight. Alias for FLYING \n\nModes: \nSELF: For the user;\nOTHER: For the target entity.
        FREEZE: FreezeEffect? { type: FREEZE } # Modifies the user or target entity freezing ticks (ie. powdered snow effect)
        FURNACEBURNTIME: FurnaceBurnTimeEffect? { type: FURNACEBURNTIME } # Modifies a furnace's burn time
        GIVEITEM: GiveItemEffect? { type: GIVEITEM } # Gives the user or target entity an item
        GLIDING: GlidingEffect? { type: GLIDING } # Sets the gliding mode of the user or target entity (works even if an Elytra is not equipped)
        HEALTH: HealthEffect? { type: HEALTH } # Modifies the health of the user or target entity. Also rounds down to the nearest hitpoint/half a heart
        HUNGER: HungerEffect? { type: HUNGER } # Modifies the hunger value of the user or target entity
        IGNITE: IgniteEffect? { type: IGNITE } # Sets the user or target entity on fire. Same as FIRE
        ITEMAMOUNT: ItemAmountEffect? { type: ITEMAMOUNT } # Modifies the item amount
        ITEMMATERIAL: ItemMaterialEffect? { type: ITEMMATERIAL } # Changes the item type in a slot
        ITEMSTACK: ItemStackWrapperEffect? { type: ITEMSTACK } # Acts like a trigger. \nTriggers for the item in the slot. \nThe item will be set to the item in the slot
        KNOCKBACK: KnockbackEffect? { type: KNOCKBACK } # Applies a velocity to the target entity in the direction that the user is looking as the direction
        LAUNCH: LaunchEffect? { type: LAUNCH } # Launches an entity. \nMode `OTHER`: Launched in the direction of the target entity. \nMode `SELF`: Launched in the direction the user is facing
        LIGHTNING: LightningEffect? { type: LIGHTNING } # Summons lightning on the user or target entity.
        LOCATIONCUBE: LocationCubeEffect? { type: LOCATIONCUBE } # Acts like a trigger. \nTriggers for every location in the cube around the user or target entity. \nThe location will be set as the location the trigger triggers for
        LOCATIONOFFSET: LocationOffsetEffect? { type: LOCATIONOFFSET } # Acts like a trigger. \nTriggers the location of the user or target entity after being offseted. \nThe location will be set as the location the trigger triggers for
        LOSETARGET: LoseTargetEffect? { type: LOSETARGET } # Make the user lose interest in the current target
        LUNGE: LungeEffect? { type: LUNGE } # Applies an acceleration to the user or the target entity based on the direction the entity is looking
        MESSAGE: MessageEffect? { type: MESSAGE } # Sends a chat message to the user or target player
        METADATA: MetadataEffect? { type: METADATA } # Modifies a user defined variable
        MODIFY: ModifyEffect? { type: MODIFY } # Modifies a variable, either user defined or not
        NEAREST: NearestEffect? { type: NEAREST } # Acts like a trigger. \nTriggers for the nearest entity in the radius. \nThe target entity will be set as the nearest entity
        PARTICLE: ParticleEffect? { type: PARTICLE } # Spawns particles
        PICKUP: Pickup? { type: PICKUP } # Pick up the target entity and places it on the user's head
        PLACEBLOCK: PlaceBlockEffect? { type: PLACEBLOCK } # Replaces a block at the location for an amount of time. Retains the original block data
        PLAYTRACK: PlayTrackEffect!  #
        POTION: Potion? { type: POTION } # Applies the potion effect to the user or target entity
        PROJECTILE: ProjectileEffect? { type: PROJECTILE } # Shoots an entity from the user. \nMode `SELF`: Shoots in the direction that the user is looking. \nMode `OTHER`: Shoots at the target entity. \nMode `LOCATION`: Shoots at the location
        RANDOMTELEPORT: RandomTeleportEffect? { type: RANDOMTELEPORT } # Teleports the user or target entity a random distance
        RAYTRACE: RaytraceEffect? { type: RAYTRACE } # Acts like a trigger. \nSends out a raytrace that collides with entities or blocks in the direction that the user or target entity is looking. \nThe target entity will be set as the collided entity. \nThe location will be set as the location of the collided block
        REMOVEENTITY: RemoveEntityEffect? { type: REMOVEENTITY } # Removes the user or target entity
        REMOVEPOTION: RemovePotionEffect? { type: REMOVEPOTION } # Removes potion effects from the user or target entity
        REPULSE: RepulseEffect? { type: REPULSE } # Repulse the target entity
        RESIZE: ResizeEffect? { type: RESIZE } # Resizes the user or target entity (for slimes, magma cubes, and phantoms)
        SCRAMBLEINVENTORY: ScrambleInventoryEffect? { type: SCRAMBLEINVENTORY } # Scrambles the inventory of the user or target entity
        SHOOTER: ShooterEffect? { type: SHOOTER } # Acts like a trigger. \nTriggers for the target entity. \nThe new target entity will be set as the source of the projectile if the old target entity is a projectile, otherwise the target entity will remain the same
        SMITE: LightningEffect? { type: SMITE } # Summons lightning on the user or target entity.
        SOUND: SoundEffect? { type: SOUND } # Plays a sound at the location or at the location of the user or target entity
        SPAWNENTITY: SpawnEffect? { type: SPAWNENTITY } # Spawns an entity at the location or the location of the user or target entity
        SWAP: SwapEffect? { type: SWAP } # Swaps the position of the user and target entity
        SWITCHEROO: SwitcherooWrapperEffect? { type: SWITCHEROO } # Acts like a trigger. \nThe target entity will be set as the original user.\n the user will be set as the original target entity
        TARGET: TargetEntityEffect? { type: TARGET } # If the user is a mob, sets the target of the user to the target entity
        TELEPORT: TeleportEffect? { type: TELEPORT } # Teleports the user to the location or the location of the target entity
        TIMER: TimerEffect? { type: TIMER } # Acts like a trigger. \nTriggers for a number of times with a period and initial delay. \nTarget items will be forwarded
        VEINMINER: VeinMinerEffect? { type: VEINMINER } # Breaks surrounding blocks around a location recursively
        VELOCITY: VelocityEffect? { type: VELOCITY } # Modifies the velocity of the user or target entity. Same as FLING
        WAIT: WaitEffect? { type: WAIT } # Acts like a trigger. \nWaits a duration of time before it triggers
        WEB: BlockEntityEffect? { type: WEB } # Change the block at target entity for a duration of time, then change it back. Same as WEB
        WRAPPER: WrapperEffect? { type: WRAPPER } # Acts like a trigger
EntityComponent: union(unionIdentifier = type)!  # TODO
    unions: 
        /AbstractHorse/: AbstractHorseComponent!  # TODO
        /Ageable/: AgeableComponent!  # TODO
        /Arrow/: ArrowComponent!  # TODO
        /Axolotl/: AxolotlComponent!  # TODO
        /ChestedHorse/: ChestedHorseComponent!  # TODO
        /Colorable/: ColorableComponent!  # TODO
        /Creeper/: CreeperComponent!  # TODO
        /ExperienceOrb/: ExperienceOrbComponent!  # TODO
        /Explosive/: ExplosiveComponent!  # TODO
        /FallingBlock/: FallingBlockComponent!  # TODO
        /Hoglin/: ZombifiableComponent!  # TODO
        /Horse/: HorseComponent!  # TODO
        /Item/: DroppedItemComponent!  # TODO
        /LivingEntity/: LivingEntityComponent!  # TODO
        /Llama/: LlamaComponent!  # TODO
        /Phantom/: SizeComponent!  # TODO
        /PiglinAbstract/: ZombifiableComponent!  # TODO
        /Rabbit/: RabbitComponent!  # TODO
        /Slime/: SizeComponent!  # TODO
        /SpectralArrow/: SpectralArrowComponent!  # TODO
        /ThrowableProjectile/: ThrowableProjectileComponent!  # TODO
        /ThrownPotion/: PotionEntityComponent!  # TODO
        /TNTPrimed/: PrimedTntComponent!  # TODO
        /Trident/: AbstractArrowComponent!  # TODO
        /WitherSkull/: WitherSkullComponent!  # TODO
        /Wolf/: WolfComponent!  # TODO
EntityData: union(unionIdentifier = type)! {type: "ZOMBIE"} # 
    properties: 
        nameTag: string?  #
        shouldDespawn: boolean? true #
        customNameVisible: boolean? false #
        silent: boolean? false #
        visualFire: boolean? false #
        attributes: {Attribute: number}? {} #
        passenger: EntityData? {} #
    unions: 
        /AbstractHorse/: AbstractHorseComponent!  #
        /Ageable/: AgeableComponent!  #
        /Arrow/: ArrowComponent!  #
        /Axolotl/: AxolotlComponent!  #
        /Colorable/: ColorableComponent!  #
        /Creeper/: CreeperComponent!  #
        /ExperienceOrb/: ExperienceOrbComponent!  #
        /Explosive/: ExplosiveComponent!  #
        /FallingBlock/: FallingBlockComponent!  #
        /Hoglin/: ZombifiableComponent!  #
        /Horse/: HorseComponent!  #
        /Item/: DroppedItemComponent!  #
        /LivingEntity/: LivingEntityComponent!  #
        /Llama/: LlamaComponent!  #
        /Phantom/: SizeComponent!  #
        /PiglinAbstract/: ZombifiableComponent!  #
        /Rabbit/: RabbitComponent!  #
        /Slime/: SizeComponent!  #
        /SpectralArrow/: SpectralArrowComponent!  #
        /ThrowableProjectile/: ThrowableProjectileComponent!  #
        /ThrownPotion/: PotionEntityComponent!  #
        /TNTPrimed/: PrimedTntComponent!  #
        /Trident/: AbstractArrowComponent!  #
        /WitherSkull/: WitherSkullComponent!  #
        /Wolf/: WolfComponent!  #
Shape: union(unionIdentifier = type)!  # TODO
    unions: 
        EARS: Ears!  #
        FAIRY_WINGS: FairyWings!  #
        HALO: Halo!  #
        HEART: Heart!  #
        HELIX: Helix!  #
        POINT: Point!  #
        WINGS: Wings!  #
        WISP: Wisp!  #
SkillData: union(unionIdentifier = skill)!  # 
    properties: 
        conditions: ConditionListWrapper? {} # The conditions to check before running the skill. Requires SkillsLibrary
        skill: string?  # The type of skill
        respectProtectionPlugins: boolean? true # Whether to respect protection plugins
        respect_protection_plugins: boolean? true # Whether to respect protection plugins
    unions: 
        ATTRIBUTE: AttributeSkillData? { skill: ATTRIBUTE } # Modifies an attribute owned by the user or target entity. Does not support conditions
        AURA: AuraData? { skill: AURA } # Gives every entity in the radius a potion effect
        BEASTCONTROL: BeastControlData!  #
        BLOCK_SPELL: PlaceBlockSpell? { skill: BLOCK_SPELL } # A spell that places a block
        BLOCKDROPS: BlockDropsData? { skill: BLOCKDROPS } # Changes the block drops of a block
        BLOCKRAY: BlockRayData? { skill: BLOCKRAY } # Changes the block the player is looking at
        CLIMB: ClimbData? { skill: CLIMB } # Lets the player climb walls
        CONSUME: ConsumeSkillData? { skill: CONSUME } # Gives the player a potion effect and food points/hunger when the player eats a certain item
        CONVERTBLOCK: ConvertBlockData? { skill: CONVERTBLOCK } # Adds the ability to convert a block when right clicking a block
        CONVERTDROPS: ConvertDropsData? { skill: CONVERTDROPS } # Converts item drops from breaking blocks
        CONVERTITEM: ConvertItemData? { skill: CONVERTITEM } # Converts the input item into the output item when the user picks up an item
        CRAFTING: CraftingData? { skill: CRAFTING } # Enables the hero to use this recipe
        CREEPER: CreeperData? { skill: CREEPER } # Creates an explosion when the user sneaks on the ground until the explosion
        CUSTOM: CustomData!  #
        CUSTOM_SPELL: CustomSpell!  #
        DAMAGEMODIFIER: DamageModifierData? { skill: DAMAGEMODIFIER } # Constrains damage, with optional easing out. \nDoes not support conditions currently
        DAMAGEPOTION: DamagePotionData? { skill: DAMAGEPOTION } # Gives the player a potion effect when damaged
        DAMAGERESISTANCE: DamageResistanceData? { skill: DAMAGERESISTANCE } # Multiplies damages taken, and optionally gives a potion effect
        DECOY: DecoyData? { skill: DECOY } # Creates an armour stand in the place of the player when sneaking. The armour stand will be wearing a leather armour and a player head
        EGGLAYER: EggLayerData? { skill: EGGLAYER } # Creates drops of a specific item
        ERASER: EraserData? { skill: ERASER } # Removes another player's power temporarily
        EXPLOSION_SPELL: ExplosionSpell? { skill: EXPLOSION_SPELL } # A spell that spawns tnt
        FANGS_SPELL: FangsSpell? { skill: FANGS_SPELL } # A spell that spawns Evoker fangs
        FLIGHT: BlankData? { skill: FLIGHT } # Let's the hero use creative flight
        GIVEITEM: GiveItemData? { skill: GIVEITEM } # Gives the user an item
        GUN: GunData? { skill: GUN } # Shoots the gun in the direction that the user is looking at when the user right clicks if the user holds the gun item
        HEARTSTEAL: HeartStealData? { skill: HEARTSTEAL } # Gives max hearts on kill
        INSTANTBREAK: InstantBreakData? { skill: INSTANTBREAK } # Allows the player to break certain blocks instantly. This will use a custom tool with enchantments of the item in hand
        KILLPOTION: KillPotionData? { skill: KILLPOTION } # Applies a potion effect everytime the hero kills an entity
        LIFESTEAL: LifestealData? { skill: LIFESTEAL } # Gives a percentage of the damage dealt to an entity as health to the user, cannot exceed maximum hp
        LIGHT: LightSkillData? { skill: LIGHT } # Applies a potion effect when the user is at a light level above 10
        LIGHTNING_SPELL: LightningSpell? { skill: LIGHTNING_SPELL } # A spell that summons lightning where the player is looking
        NOHUNGER: NoHungerData? { skill: NOHUNGER } # Makes the hero's hunger not go down after a certain level
        OHKO: OHKOData? { skill: OHKO } # Kills entities in one hit
        PHASE: PhaseData? { skill: PHASE } # Allows the player to phase through the ground
        PICKPOCKET: PickpocketData? { skill: PICKPOCKET } # Allows the hero to look at another player's inventory or drop a villager's inventory with right click
        POTIONEFFECT: PotionEffectSkillData? { skill: POTIONEFFECT } # Applies a potion effect continuously to the hero
        POTIONGIFTER: PotionGifterSkillData? { skill: POTIONGIFTER } # Gives a potion effect to right clicked entities
        PROJECTILE_SPELL: LaunchProjectileSpell? { skill: PROJECTILE_SPELL } # A spell that launches an entity in the direction the player is looking
        REMOTEDETONATION: RemoteDetonationData? { skill: REMOTEDETONATION } # Creates an explosion at the entity the user is looking at when the user sneaks
        REPULSION: RepulsionData? { skill: REPULSION } # Repulses all nearby entities when the user sneaks
        SHIELD: ShieldData? { skill: SHIELD } # Sets the shields cooldown when the user take damage
        SLAM: SlamData? { skill: SLAM } # Allows the player to jump high up in the air and do a slam, damaging entities near the impact\nTriggered with punch
        SLIME: SlimeData? { skill: SLIME } # Let's the hero bounce around like a slime, also adds horizontal velocity in the direction the player is facing
        SNEAK: SneakData? { skill: SNEAK } # Prevents being targeted by entities
        SNEAKINGPOTION: SneakingPotionData? { skill: SNEAKINGPOTION } # Gives the hero a potion effect when sneaking
        STRONGMAN: StrongmanData? { skill: STRONGMAN } # Allows the player to pick up entities with right click\nand throw them in the direction that the player is looking by sneaking\nThis skill also prevents sitting in a vehicle\n
        SUMMON: SummonSkillData? { skill: SUMMON } # On punch with an empty hand, summons an entity where the player is looking
        TELEPORT: TeleportData? { skill: TELEPORT } # Teleports the player in the direction that they are looking at
        THROWER: ThrowerData? { skill: THROWER } # Throws an entity in the direction the player is looking
        TRANSMUTATION_SPELL: TransmutationSpell? { skill: TRANSMUTATION_SPELL } # A spell that replaces blocks
        WALKER: WalkerData? { skill: WALKER } # Places blocks below the player
        WEATHERDAMAGE: WeatherDamageData? { skill: WEATHERDAMAGE } # Makes the player take damage every  when it's raining
SpellData: union(unionIdentifier = skill, superdoc = SkillData)!  # 
    properties: 
        fuel: Material? REDSTONE # The fuel that will be used to cast the spell
        spellName: string?  # undocumented# # The name of the spell.\n \nDefaults to the type of spell
        displayName: string? <purple><spellName> # The display name of the book to cast the spell\n \n\"<spellName>\" will be replaced with the spell name\n\"<cooldown>\" will be replaced with the cooldown time\n\"<fuel>\" will be replaced with the fuel item\n\"<cost>\" will be replaced with the fuel cost\n
        cooldownMessage: string? <spellName> has <currentcooldown> seconds remaining. # The message to display when the spell is on cooldown\n     \n    \"<currentcooldown>\" will be replaced to the current cooldown in seconds\n    \"<spellName>\" will be replaced to the spell name\n
        moreFuelMessage: string? This spell needs <fuelneeded> more <fuel> # The message to display when the spell needs more fuel\n \n\"<fuelneeded>\" will be replaced to the amount of fuel needed\n\"<fuel>\" will be replaced to the fuel material\n
        cooldown: number? 1 # The cooldown of the spell in seconds
        cost: integer? 1 # How much fuel is needed to cast the spell
        lore: string[]? [] # The lore of the book to cast the spell\n \n\"<spellName>\" will be replaced with the spell name\n\"<cooldown>\" will be replaced with the cooldown time\n\"<fuel>\" will be replaced with the fuel item\n\"<cost>\" will be replaced with the fuel cost\n
        displayNameFormat: string? <purple><spellName> # The display name of the book to cast the spell\n \n\"<spellName>\" will be replaced with the spell name\n\"<cooldown>\" will be replaced with the cooldown time\n\"<fuel>\" will be replaced with the fuel item\n\"<cost>\" will be replaced with the fuel cost\n
        loreFormat: string[]? [] # The lore of the book to cast the spell\n \n\"<spellName>\" will be replaced with the spell name\n\"<cooldown>\" will be replaced with the cooldown time\n\"<fuel>\" will be replaced with the fuel item\n\"<cost>\" will be replaced with the fuel cost\n
    unions: 
        BLOCK_SPELL: PlaceBlockSpell? { skill: BLOCK_SPELL } # A spell that places a block
        CUSTOM_SPELL: CustomSpell!  #
        EXPLOSION_SPELL: ExplosionSpell? { skill: EXPLOSION_SPELL } # A spell that spawns tnt
        FANGS_SPELL: FangsSpell? { skill: FANGS_SPELL } # A spell that spawns Evoker fangs
        LIGHTNING_SPELL: LightningSpell? { skill: LIGHTNING_SPELL } # A spell that summons lightning where the player is looking
        PROJECTILE_SPELL: LaunchProjectileSpell? { skill: PROJECTILE_SPELL } # A spell that launches an entity in the direction the player is looking
        TRANSMUTATION_SPELL: TransmutationSpell? { skill: TRANSMUTATION_SPELL } # A spell that replaces blocks
TriggerData: union(unionIdentifier = type)!  # 
    properties: 
        type: string!  # TODO
    unions: 
        BECOMEVEHICLE: object? { type: BECOMEVEHICLE } # Triggers when an entity enters the user, thus using the user as a vehicle. \nThe target entity will be set as the entering entity
        BLOCKBREAK: object? { type: BLOCKBREAK } # Triggers when the user breaks a block. \nThe location will be set as the location of the broken block
        CHANGEMAINHAND: object? { type: CHANGEMAINHAND } # Triggers when the user changes where the main hand slot is (i.e. scrolls or hits a number). \nThe item will be set as the item in the new slot
        COMBAT: object? { type: COMBAT } # Triggers when the user damages an entity or gets damaged by an entity. \nThe target entity will be set as the damaged entity or the damaging entity respectively
        CONSUME: object? { type: CONSUME } # Triggers when the user consumed an item
        DAMAGEDBYENTITY: object? { type: DAMAGEDBYENTITY } # Triggers when an entity damages the user. \nThe target entity will be set as the damaging entity
        DAMAGEDENTITY: object? { type: DAMAGEDENTITY } # Triggers when the user damage an entity. \nThe target entity will be set as the damaged entity
        DEATH: object? { type: DEATH } # Triggers when the user is killed. \nThe target entity will be set as the killer if it exist
        ENTERVEHICLE: object? { type: ENTERVEHICLE } # Triggers when the user enters a vehicle. \nThe target entity will be set as the vehicle
        EQUIPARMOR: object? { type: EQUIPARMOR } # Triggers when the user equips an armour. \nThe item will be set as the equiped item
        EXITVEHICLE: object? { type: EXITVEHICLE } # Triggers when the user exits a vehicle. \nThe target entity will be set as the vehicle
        INTERACTENTITY: object? { type: INTERACTENTITY } # Triggers when the user right clicks an entity. \nThe target entity will be set as the interacted entity
        KILL: object? { type: KILL } # Triggers when the user kills an entity. \nThe target entity will be set as the killed entity
        LAUNCHPROJECTILE: object? { type: LAUNCHPROJECTILE } # Triggers when the user launched a projectile. \nThe target entity will be set as the launched projectile
        MOVE: object? { type: MOVE } # Triggers when the user moves. \nThe location will be set as the location the user moves to
        PLAYERJOIN: object? { type: PLAYERJOIN } # Triggers when the user joins the server
        PLAYERJUMP: object? { type: PLAYERJUMP } # Triggers when the user jumps
        PLAYERQUIT: object? { type: PLAYERQUIT } # Triggers when the user exits the server
        PROJECTILEHIT: object? { type: PROJECTILEHIT } # Triggers when a projectile shot by the user landed and/or hits an entity. \nThe target entity will be set as the projectile
        RIPTIDE: object? { type: RIPTIDE } # Triggers when the user activates the riptide enchantment
        SNEAK: object? { type: SNEAK } # Triggers when the user sneaks
        SPAWN: object? { type: SPAWN } # Triggers when the user spawns
        SPRINT: object? { type: SPRINT } # Triggers when the user starts or stops sprinting
        SWAPHANDS: object? { type: SWAPHANDS } # Triggers when the user swaps hands
        TAME: object? { type: TAME } # Triggers when the user tames an entity. \nThe target entity will be set as the tamed entity
        TARGET: object? { type: TARGET } # Triggers when the user targets an entity. \nThe target entity will be set as the target
        TARGETED: object? { type: TARGETED } # Triggers when the user is targeted by an entity. \nThe target entity will be set as the entity that targeted the user
        TOGGLEGLIDE: object? { type: TOGGLEGLIDE } # Triggers when the user glides or unglides
        TOTEM: object? { type: TOTEM } # Triggers when the user activates a totem. \nThe target entity will be set as the killer of the user
        DAMAGED: DamageData? { type: DAMAGED } # Triggers when the user gets damaged
        DAMAGEDBYPROJECTILE: ProjectileData? { type: DAMAGEDBYPROJECTILE } # Triggers when an entity damages the user. \nIf the damaging entity is a projectile, the target entity will be set as the source of the projectile. \nOtherwise, The target entity will be set as the damaging entity
        DAMAGEDENTITYWITHPROJECTILE: ProjectileData? { type: DAMAGEDENTITYWITHPROJECTILE } # Triggers when the user damages an entity directly or with a projectile. \nThe target entity will be set as the damaged entity
        GAINEDHERO: TriggerData!  #
        INTERACT: InteractData? { type: INTERACT } # Triggers when the user interacts with a block or air
        LOOP: LoopData? { type: LOOP } # Triggers periodically every couple of ticks
        LOSTHERO: TriggerData!  #
        POTIONEFFECT: PotionEffectTriggerData? { type: POTIONEFFECT } # Triggers when a potion effect is applied to the user
        PROJECTILECOMBAT: ProjectileData? { type: PROJECTILECOMBAT } # Acts like the DAMAGEDBYPROJECTILE and DAMAGEDENTITYWITHPROJECTILE triggers combined
AbstractArrowComponent: object(additionalProperties)?  # 
    properties: 
        knockbackStrength: integer? 0 #
        damage: number? 2.0 #
        pierceLevel: integer? 0 #
        critical: boolean? false #
        pickupStatus: AbstractArrow.PickupStatus? DISALLOWED #
AbstractHorseComponent: object(additionalProperties)?  # 
    properties: 
        tamingDifficulty: integer? 1 #
        jumpStrength: number? 0.7 #
        tamed: boolean? false #
        hasSaddle: boolean? false #
ActionBarEffect: object(superdoc = Effect)?  # Sends an action bar to the user or target entity
    properties: 
        mode: enum! SELF # The mode of operation
            values: 
              - ALL
              - OTHER
              - SELF
        message: ExpressiveMessage?  # The message to send
AgeableComponent: object(additionalProperties)?  # 
    properties: 
        isBaby: boolean? false #
AOE: object(superdoc = WrapperEffect, superdoc = Effect)?  # Acts like a trigger. \nTriggers for every entity in the range. \nThe target entity will be set to the entity this trigger triggers for
    properties: 
        mode: enum! SELF # The mode of operation
            values: 
              - ALL
              - LOCATION
              - OTHER
              - SELF
        radius: Expression? 5 # Half the side length of the box
ArrowComponent: object(additionalProperties, superdoc = AbstractArrowComponent)?  # 
    properties: 
        potionType: PotionType?  #
ArrowEffect: object(superdoc = Effect)?  # Shoot an arrow to the location of the target entity
    properties: 
        mode: enum! OTHER # The mode of operation
            values: 
              - ALL
              - OTHER
        velocity: Expression? 1.0 # Used to determine the time that it takes to hit by (pythagoras distance)/velocity
        damage: Expression? 4 # If projectile entity is an arrow, the damage that the arrow will do
        entityData: EntityData? { type: \"ARROW\"} # The entity launch
        fireTicks: Expression? 0 # The amount of ticks the projectile will be on fire
        entity: EntityData? { type: \"ARROW\"} # The entity launch
AttributeEffect: object(superdoc = ModifyEffect, superdoc = Effect)?  # Modifies an attribute owned by the user or target entity
    properties: 
        mode: enum! SELF # The mode of operation
            values: 
              - ALL
              - OTHER
              - SELF
        attribute: Attribute?  # The attribute to modify. The name of the attribute should exclude the \"GENERIC_\" prefix
AttributesData: object?  # 
    properties: 
        attributes: {Attribute: number}? {} #
        uniqueKey: string?  #
        equipmentSlot: EquipmentSlotGroup? ANY #
        operation: AttributesData.Operation? MULTIPLY_SCALAR #
        unique_key: string?  #
AttributeSkillData: object(superdoc = SkillData)?  # Modifies an attribute owned by the user or target entity. Does not support conditions
    properties: 
        attributes: {Attribute: number}!  #
        equipmentSlot: EquipmentSlotGroup!  #
        operation: AttributesData.Operation!  #
        uniqueKey: string!  #
        equipment_slot: EquipmentSlotGroup!  #
        unique_key: string!  #
AuraData: object(superdoc = PotionEffectData, superdoc = SkillData)?  # 
    properties: 
        radius: number? 5 # The radius of the aura
AxolotlComponent: object(additionalProperties)?  # 
    properties: 
        variant: Axolotl.Variant?  # TODO
BeastControlData: object(superdoc = SkillData)?  # 
    properties: 
        maxDistance: number? 32.0 #
        targetMobs: boolean? true #
        glowDuration: number? 3.0 #
        attackItself: boolean? false #
BiomeCondition: object(superdoc = Condition)?  # Checks if the biome that the user, target entity, or location is in is one of the listed biomes
    properties: 
        mode: enum! SELF # The mode of operation
            values: 
              - ALL
              - LOCATION
              - OTHER
              - SELF
        biomes: Biome[]? [] # The list of biomes
BlankData: object(superdoc = SkillData)! {} # Let's the hero use creative flight
BlockCondition: object(superdoc = Condition)?  # Checks if the location has one of the listed blocks
    properties: 
        mode: enum! LOCATION # The mode of operation
            values: 
              - ALL
              - LOCATION
        allowedMaterials: Material[]? [] # The list of blocks
        materials: Material[]? [] # The list of blocks
BlockDataComparisonData: object?  # TODO
    properties: 
        types: Material[]? [] # TODO
        level: RangeData? -Infinity - Infinity # TODO
        age: RangeData? -Infinity - Infinity # TODO
BlockDataData: object?  # TODO
    properties: 
        material: Material? STONE # TODO
        level: integer? -1 # TODO
        age: integer? -1 # TODO
        type: Material? STONE # TODO
BlockDropsData: object(superdoc = SkillData)?  # Changes the block drops of a block
    properties: 
        dropToNewDrop: {Material: ItemStack}? {} # The map of block to items to drops
        replaceDrops: boolean? false # If true, the original block drop will be replaced instead of dropping like usual
        convertMap: {Material: ItemStack}? {} # The map of block to items to drops
BlockEntityEffect: object(superdoc = Effect)?  # Change the block at target entity for a duration of time, then change it back. Same as WEB
    properties: 
        mode: enum! OTHER # The mode of operation
            values: 
              - ALL
              - OTHER
        durationInTicks: Expression? -1 # The duration of time that the block will be there in ticks. If less than 0, the block will not change back
        blockToPlace: Material? COBWEB # The block to change to
        duration: Expression!  # The duration of time that the block will be there in seconds (1 is 20 ticks). If less than 0, the block will not change back
BlockRayData: object(superdoc = SkillData)?  # Changes the block the player is looking at
    properties: 
        maxDistance: integer? 20 # The max distance to the block to change
        shouldRevert: boolean? false # Whether to revert the block after it changes
        blocksToPlace: Material[]? [] # The list of blocks to change to, it will randomly pick one from the list
        blocksToReplace: Material[]? [] # The list of blocks that can be replaced
        blockRayMode: BlockRayMode?  # The mode of operation
        revertsAfter: Duration? 15.0 # How long it takes for the block to revert in seconds. Only works if `shouldRevert` is true
BonemealEffect: object(superdoc = Effect)?  # Applies bonemeal to the location or location of the user or target entity
    properties: 
        mode: enum! SELF # The mode of operation
            values: 
              - ALL
              - LOCATION
              - OTHER
              - SELF
        blockFaces: BlockFace[]? [] # The list of faces to apply bonemeal from
BookData: object?  # TODO
    properties: 
        title: string!  #
        author: string!  #
        pages: string[]!  #
CancelEffect: object(superdoc = Effect)! {} # Cancels the event that triggered this effect
    properties: 
        mode: enum! SELF # The mode of operation
            values: 
              - ALL
              - SELF
ChanceCondition: object(superdoc = Condition)?  # A chance for this condition to be true
    properties: 
        mode: enum! SELF # The mode of operation
            values: 
              - ALL
              - OTHER
              - SELF
        chance: Expression? 1.0 # The chance that is used
ChangeHeroEffect: object(superdoc = Effect)?  # 
    properties: 
        mode: enum! SELF # 
            values: 
              - ALL
              - OTHER
              - SELF
        permanent: boolean? true #
        heroName: string? erased #
        description: string?  #
        broadcast: boolean? true #
        duration: Duration? 0.0 #
ChatLanguageSettings: object?  # TODO
    properties: 
        gainedHero: string?  # TODO
        noPermission: string?  # TODO
        currentHero: string?  # TODO
        heroCommandCooldown: string?  # TODO
        invalidHeroMessage: string?  # TODO
        invalidPlayerMessage: string?  # TODO
        invalidCommandMessage: string?  # TODO
        invalidRerollGroupMessage: string?  # TODO
ChestedHorseComponent: object(additionalProperties)?  # 
    properties: 
        hasChest: boolean? false #
ClimbData: object(superdoc = SkillData)?  # Lets the player climb walls
    properties: 
        proximity: number? 0.2 #
        climbSpeed: number? 0.2 #
        debug: boolean? false #
        blocks: Material[]? [] #
        whitelist: boolean? true #
        speed: number? 0.2 #
Color: object! {red: 100, green: 0, blue: 200} # 
    properties: 
        red: integer!  #
        green: integer!  #
        blue: integer!  #
ColorableComponent: object(additionalProperties)?  # 
    properties: 
        dyeColor: DyeColor?  #
CommandEffect: object(superdoc = Effect)?  # Excecutes a list of commands
    properties: 
        mode: enum! SELF # The mode of operation
            values: 
              - ALL
              - OTHER
              - SELF
        executor: CommandEffect.Executor? CONSOLE # The executor that will execute the command
        commands: ExpressiveMessage[]? [] # The list of commands to execute
ComparisonCondition: object(superdoc = Condition)?  # Compares a variable
    properties: 
        value: Expression!  # The value to compare against
        comparison: ComparisonCondition.Comparison? EQUAL # The comparison to use
ConfigYaml: object?  # 
    properties: 
        config_version: string?  #
        powerOnStart: PowerOnStartSettings?  #
        gui: GUISettings?  #
        heroCommand: HeroCommandSettings?  #
        defaultHero: Superhero?  #
        disabledWorlds: string[]?  #
ConsumeSkillData: object(superdoc = PotionEffectData, superdoc = SkillData)?  # 
    properties: 
        material: Material? DIRT # The item that can be consumed
        hunger: integer? 0 # The food points/hunger that the player will get after easting
ConvertBlockData: object(superdoc = CooldownData, superdoc = SkillData)?  # Adds the ability to convert a block when right clicking a block
    properties: 
        inputBlocks: Material[]? [] # The list of blocks that can be converted
        outputBlock: Material? GOLD_BLOCK # The result of the conversion
ConvertDropsData: object(superdoc = SkillData)?  # Converts item drops from breaking blocks
    properties: 
        dropToNewDrop: {Material: ItemStack}? {} # The mapping from drop to new drop
        ignoredBlocks: Material[]? [] # The list of blocks to not convert drops from
        ignoreSilkTouch: boolean? false # Whether to still do the conversion if the block is mined with silk touch
        convertMap: {Material: ItemStack}? {} # The mapping from drop to new drop
ConvertItemData: object(superdoc = SkillData)?  # Converts the input item into the output item when the user picks up an item
    properties: 
        inputItem: ItemStack?  # The input item to convert
        outputItem: ItemStack?  # The item to convert to
        chance: number? 1 # The chance of the conversion
CooldownCondition: object(superdoc = Condition)?  # Checks if the time since the get last effect triggered is after the cooldown
    properties: 
        mode: enum! SELF # The mode of operation
            values: 
              - ALL
              - OTHER
              - SELF
        cooldown: Expression? 10 # The cooldown time that is used in seconds
CooldownData: object(superdoc = SkillData)?  # TODO
    properties: 
        cooldown: number? 0 # The cooldown in seconds
        cooldownMessage: string? You have <currentcooldown> seconds remaining before you can use the ability again! # The message for when the cooldown is not over\n\n\"<currentcooldown>\" will be replaced by the remaining cooldown in seconds
CraftingData: object(superdoc = SkillData)?  # Enables the hero to use this recipe
    properties: 
        shapeless: ShapelessRecipeData!  # TODO
        shaped: ShapedRecipeData!  # TODO
CreeperComponent: object(additionalProperties)?  # 
    properties: 
        fuse: integer? 30 #
        ignite: boolean? false #
        explosionRadius: integer? 3 #
        powered: boolean? false #
CreeperData: object(superdoc = CooldownData, superdoc = SkillData)?  # Creates an explosion when the user sneaks on the ground until the explosion
    properties: 
        fuse: Duration? 2.0 # The time to wait until the explosion in seconds (1 is 20 ticks)
        creeperPower: number? 1 # The power of the explosion
        upwardsVelocity: number? 2.5 # The upwards velocity to apply to the user
        slowfallDuration: Duration? 7.0 # The duration of the slowfall potion in seconds (1 is 20 ticks)
        creeper_power: number? 1 # The power of the explosion
        upwards_velocity: number? 2.5 # The upwards velocity to apply to the user
        slowfall_duration: Duration? 7.0 # The duration of the slowfall potion in seconds (1 is 20 ticks)
CustomData: object(superdoc = SkillData)?  # 
    properties: 
        trigger: TriggerData!  #
        effects: EffectList!  #
        conditions: ConditionList!  #
CustomSpell: object(superdoc = SpellData, superdoc = SkillData)?  # 
    properties: 
        effects: EffectList!  #
DamageData: object(superdoc = TriggerData)?  # Triggers when the user gets damaged
    properties: 
        damageCauses: EntityDamageEvent.DamageCause[]?  # The causes of damage. Defaults to all damage causes
        causes: EntityDamageEvent.DamageCause[]?  # The causes of damage. Defaults to all damage causes
DamageEffect: object(superdoc = Effect)?  # Damages the user or the target entity
    properties: 
        mode: enum! SELF # The mode of operation
            values: 
              - ALL
              - OTHER
              - SELF
        damage: Expression? 5 # The amount damage that will be dealt
        damageCause: EntityDamageEvent.DamageCause? CUSTOM # The type of damage that will be dealt
        shouldTriggerEvents: boolean? false # Whether to make the damage come from the user, thus triggering things like thorns
DamageModifierData: object(superdoc = SkillData)?  # Constrains damage, with optional easing out. \nDoes not support conditions currently
    properties: 
        entities: EntityType[]? [] #
        causes: EntityDamageEvent.DamageCause[]? [] #
        whitelist: boolean? false #
        expectedMaxDamage: number? 30 #
        maxDamage: number? 15 #
        minDamage: number? 0 #
        priority: integer? 0 #
        incoming: boolean? false #
        outgoing: boolean? false #
        eased: boolean? false #
        limitProjectiles: boolean? true #
DamagePotionData: object(superdoc = PotionEffectData, superdoc = SkillData)?  # 
    properties: 
        damageCauses: EntityDamageEvent.DamageCause[]? [] #
        damageCause: EntityDamageEvent.DamageCause[]? [] #
DamageResistanceData: object(superdoc = PotionEffectData, superdoc = SkillData)?  # 
    properties: 
        damageMultiplier: number? 0 # The multiplier on the damage
        damageCauses: EntityDamageEvent.DamageCause[]?  # The causes of damage that will be effected
        damageCause: EntityDamageEvent.DamageCause[]?  # The causes of damage that will be effected
DatabaseSettings: object?  # TODO
    properties: 
        type: string? YAML #
        host: string? this needs filling with your host name if using mysql #
        port: integer? 3306 #
        name: string? this needs filling with the database name if using mysql #
        username: string? this needs filling with the username of the account being used to connect #
        password: string? this needs filling with the password being used to connect #
DatabaseYaml: object?  # 
    properties: 
        database: DatabaseSettings?  # TODO
        config_version: string?  # TODO
DecoyData: object(superdoc = SkillData)?  # Creates an armour stand in the place of the player when sneaking. The armour stand will be wearing a leather armour and a player head
    properties: 
        color: Color?  #
        base64Skin: string? SELF #
        base64skin: string? SELF #
DisguiseEffect: object(superdoc = Effect)?  # 
    properties: 
        mode: enum! SELF # 
            values: 
              - ALL
              - OTHER
              - SELF
        enable: boolean?  #
        entityType: EntityType!  #
        entity: EntityType!  #
DistanceCondition: object(superdoc = Condition)?  # Checks if the distance between the user and target entity is in the range
    properties: 
        mode: enum! OTHER # The mode of operation
            values: 
              - ALL
              - LOCATION
              - OTHER
        distance: RangeData? -Infinity - Infinity # The distance range in blocks
DroppedItemComponent: object(additionalProperties)?  # 
    properties: 
        stackData: ItemStackData?  #
Ears: object(superdoc = Shape)?  # 
    properties: 
        height: number? 0.2 # TODO
        frequency: number? 0.05 # TODO
        size: number? 1 # TODO
        spread: number? 0.2 # TODO
EffectData: object?  # TODO
    properties: 
        particles: ParticleData[]? [] # TODO
        name: string?  # TODO
EggLayerData: object(superdoc = ItemStackData, superdoc = SkillData)?  # 
    properties: 
        tickDelay: Duration? 15.0 # The delay between item drops
EnchantComparisonData: object?  # TODO
    properties: 
        enchantMap: {Enchantment: RangeData}? {} #
EntityWhitelistCondition: object(superdoc = Condition)?  # Checks the target entity against this whitelist/blacklist
    properties: 
        mode: enum! SELF # The mode of operation
            values: 
              - ALL
              - OTHER
              - SELF
        whitelist: boolean? true # If true, the entities property will whitelist. If false, the entities property will blacklist
        entities: EntityType[]? [] # If true, the entities property will whitelist. If false, the entities property will blacklist
EquipableData: object(superdoc = ItemStack)?  # 
    properties: 
        droprate: number? 0.1 #
EquipmentData: object?  # 
    properties: 
        head: EquipableData?  #
        chest: EquipableData?  #
        legs: EquipableData?  #
        feet: EquipableData?  #
        mainhand: EquipableData?  #
        offhand: EquipableData?  #
        helmet: EquipableData?  #
        chestplate: EquipableData?  #
        leggings: EquipableData?  #
        boots: EquipableData?  #
        hand: EquipableData?  #
EraserData: object(superdoc = CooldownData, superdoc = SkillData)?  # Removes another player's power temporarily
    properties: 
        range: number? 30 # The maximum distance to the target player to be erased
        removedMessage: string? <player> has had their power erased temporarily! # The message to send to the user and erased player when their powers are removed
        returnedMessage: string? <player> has had their power reinstated! # The message to send to the user and erased player when their powers are reinstated
        duration: Duration? 7.5 # How long the powers are erased in seconds
ExperienceOrbComponent: object(additionalProperties)?  # 
    properties: 
        experience: integer? 1 #
ExplosionSpell: object(superdoc = SpellData, superdoc = SkillData)! {} # A spell that spawns tnt
ExplosiveComponent: object(additionalProperties)?  # 
    properties: 
        yield: number?  #
        isIncendiary: boolean? false #
FairyWings: object(superdoc = Shape)?  # 
    properties: 
        height: number? 1 #
        frequency: number? 0.05 #
        size: number? 1 #
FallingBlockComponent: object(additionalProperties)?  # 
    properties: 
        blockData: BlockData?  # undocumented#
        dropItem: boolean? true #
        cancelDrop: boolean? false #
        hurtEntities: boolean? false #
        damagePerBlock: number? 2 #
        maxDamage: integer? 40 #
FangsSpell: object(superdoc = SpellData, superdoc = SkillData)! {} # A spell that spawns Evoker fangs
FlyEffect: object(superdoc = Effect)?  # Sets the ability for the creative flight. Alias for FLYING \n\nModes: \nSELF: For the user;\nOTHER: For the target entity.
    properties: 
        mode: enum! SELF # The mode of operation
            values: 
              - ALL
              - OTHER
              - SELF
        fly: boolean? true # Whether to set it to enable or disable creative flight
FlyingCondition: object(superdoc = Condition)! {} # Checks if the user or target entity is flying
    properties: 
        mode: enum! SELF # The mode of operation
            values: 
              - ALL
              - OTHER
              - SELF
FreezeEffect: object(superdoc = ModifyEffect, superdoc = Effect)! {} # Modifies the user or target entity freezing ticks (ie. powdered snow effect)
    properties: 
        mode: enum! SELF # The mode of operation
            values: 
              - ALL
              - OTHER
              - SELF
FurnaceBurnTimeEffect: object(superdoc = ModifyEffect, superdoc = Effect)! {} # Modifies a furnace's burn time
    properties: 
        mode: enum! LOCATION # The mode of operation
            values: 
              - ALL
              - LOCATION
GiveItemData: object(superdoc = SkillData)?  # Gives the user an item
    properties: 
        item: ItemStack?  # The item to give
        canStore: boolean? true # If true, the item can be stored outside of the player inventory
        canDrop: boolean? true # If true, the item can be dropped
        canLoseOnDeath: boolean? true # If true, the item can be lost on death
        loseItemOnHeroLoss: boolean? true # If true, the item will be lost on if the user changes hero
        dropsOnDeath: boolean? true # If true, the item will be dropped on death
        canDropOnDeath: boolean? true # If true, the item will be dropped on death
GiveItemEffect: object(superdoc = Effect)?  # Gives the user or target entity an item
    properties: 
        mode: enum! SELF # The mode of operation
            values: 
              - ALL
              - OTHER
              - SELF
        item: ItemStack!  # The item to give
        dropIfFull: boolean? true # If true, drops the items that did not fit into the inventory
GlidingCondition: object(superdoc = Condition)?  # Checks if the user gliding
    properties: 
        mode: enum! SELF # The mode of operation
            values: 
              - ALL
              - OTHER
              - SELF
        shouldGlide: boolean? true # If true, checks if the entity is gliding. If false, it checks the opposite
        glide: boolean? true # If true, checks if the entity is gliding. If false, it checks the opposite
GlidingEffect: object(superdoc = Effect)?  # Sets the gliding mode of the user or target entity (works even if an Elytra is not equipped)
    properties: 
        mode: enum! SELF # The mode of operation
            values: 
              - ALL
              - OTHER
              - SELF
        glide: boolean? true # Whether to start or stop the gliding
GlobalRerollSettings: object?  # TODO
    properties: 
        itemEnabled: boolean? true # TODO
        eachHeroRequiresPermission: boolean?  # TODO
        itemCooldown: number?  # TODO
GUILanguageSettings: object?  # TODO
    properties: 
        name: string? Pick your hero! #
GUISettings: object?  # 
    properties: 
        startsOpen: boolean!  # TODO
        onStart: boolean!  # TODO
        closeable: boolean!  # TODO
        canClose: boolean!  # TODO
GunData: object(superdoc = CooldownData, superdoc = SkillData)?  # Shoots the gun in the direction that the user is looking at when the user right clicks if the user holds the gun item
    properties: 
        damage: number? 5.0 # The damage that will be dealt by the bullet
        maxDistance: number? 64 # The max distance the bullet can travel
        bulletSize: number? 1.0 # The size of the bullet
        item: ItemComparisonData? {} # The item that will be used as the gun
        shootSound: SoundData?  # The sound that will be played when the gun shoots
        trailParticle: ParticleData?  # The particle that will be used for the trail
        hitParticle: ParticleData?  # The particle that will be spawned at the hit location
Halo: object(superdoc = Shape)?  # 
    properties: 
        radius: number? 0.3 #
        height: number? 0.3 #
        resolution: number? 32 #
HealthCondition: object(superdoc = Condition)?  # Checks if the hp percentage of the user or target entity is in the range
    properties: 
        mode: enum! SELF # The mode of operation
            values: 
              - ALL
              - OTHER
              - SELF
        healthPercentage: RangeData? -Infinity - Infinity # The health percentage range to check againts
HealthEffect: object(superdoc = ModifyEffect, superdoc = Effect)! {} # Modifies the health of the user or target entity. Also rounds down to the nearest hitpoint/half a heart
    properties: 
        mode: enum! SELF # The mode of operation
            values: 
              - ALL
              - OTHER
              - SELF
Heart: object(superdoc = Shape)?  # 
    properties: 
        height: number? 2 #
        frequency: number? 0.05 #
        size: number? 1 #
HeartStealData: object(superdoc = SkillData)?  # Gives max hearts on kill
    properties: 
        heartsGained: integer? 2 #
        entities: EntityType[]? [] #
        maxHearts: integer? 24 #
        heartsgained: integer? 2 #
        maxhearts: integer? 24 #
HeightCondition: object(superdoc = Condition)?  # Checks if the user or target entity y coordinate is in the range
    properties: 
        mode: enum! SELF # The mode of operation
            values: 
              - ALL
              - OTHER
              - SELF
        height: RangeData? -Infinity - Infinity # The range in blocks
Helix: object(superdoc = Shape)?  # 
    properties: 
        radius: number? 0.5 #
        interval: number? 0.05 #
        speed: number? 1 #
        waveFrequency: number? 1 #
        height: number? 2 #
        wave_frequency: number? 1 #
HeroCommandSettings: object?  # 
    properties: 
        cooldown: number?  # TODO
        aliases: string[]?  # TODO
HorseComponent: object(additionalProperties)?  # 
    properties: 
        armor: ItemStack?  # TODO
        color: Horse.Color? CHESTNUT # TODO
        style: Horse.Style? NONE # TODO
HotbarSlotCondition: object(superdoc = Condition)?  # Checks if the held item/main hand in in a range of hotbar slots
    properties: 
        mode: enum! SELF # The mode of operation
            values: 
              - ALL
              - SELF
        slot: RangeData?  # The range of slots it could be in
HungerEffect: object(superdoc = ModifyEffect, superdoc = Effect)! {} # Modifies the hunger value of the user or target entity
    properties: 
        mode: enum! SELF # The mode of operation
            values: 
              - ALL
              - OTHER
              - SELF
IgniteEffect: object(superdoc = Effect)?  # Sets the user or target entity on fire. Same as FIRE
    properties: 
        mode: enum! SELF # The mode of operation
            values: 
              - ALL
              - OTHER
              - SELF
        fireTicks: Expression?  # TODO
InBlockCondition: object(superdoc = Condition)?  # Checks if the user or target entity is in one of the listed blocks
    properties: 
        mode: enum! SELF # The mode of operation
            values: 
              - ALL
              - OTHER
              - SELF
        blocks: Material[]? [] # The list of blocks
InInventoryCondition: object(superdoc = Condition)! {} # Checks if the user have their inventory GUI opened
    properties: 
        mode: enum! SELF # The mode of operation
            values: 
              - ALL
              - OTHER
              - SELF
InstantBreakData: object(superdoc = SkillData)?  # Allows the player to break certain blocks instantly. This will use a custom tool with enchantments of the item in hand
    properties: 
        instantBreakable: Material[]? [] # The list of blocks that can be broken instantly
        breakUsing: Material?  # The tool that will be used instead of what's in hand
        blocks: Material[]? [] # The list of blocks that can be broken instantly
        breakusing: Material?  # The tool that will be used instead of what's in hand
InteractData: object(superdoc = TriggerData)?  # Triggers when the user interacts with a block or air
    properties: 
        actions: Action[]?  # The interactions that will trigger this trigger
ItemAmountEffect: object(superdoc = ModifyEffect, superdoc = Effect)! {} # Modifies the item amount
    properties: 
        mode: enum! ITEM # The mode of operation
            values: 
              - ALL
              - ITEM
ItemComparisonData: object?  # TODO
    properties: 
        types: Material[]? [] # TODO
        type: Material?  # TODO
        amount: RangeData? -Infinity - Infinity # TODO
        metadata: ItemMetaComparisonData?  # TODO
ItemCondition: object(superdoc = Condition)?  # Checks the item or the item in the declared slot against the declared item
    properties: 
        mode: enum! SELF # The mode of operation
            values: 
              - ALL
              - ITEM
              - OTHER
              - SELF
        itemComparison: ItemComparisonData!  # The item to check against
        slot: InventorySlot? HAND # The slot to check
        item: ItemComparisonData!  # The item to check against
ItemMaterialEffect: object(superdoc = Effect)?  # Changes the item type in a slot
    properties: 
        mode: enum! ITEM # The mode of operation
            values: 
              - ALL
              - ITEM
        material: Material?  # The material to change it to
ItemMetaComparisonData: object?  # TODO
    properties: 
        displayName: string!  # TODO
        lore: LoreData!  # TODO
        enchants: EnchantComparisonData!  # TODO
ItemMetaData: object?  # TODO
    properties: 
        displayName: string?  # TODO
        lore: string[]?  # TODO
        isUnbreakable: boolean? false # TODO
        durability: integer? 0 # TODO
        customModelData: integer? 0 # TODO
        attributes: AttributesData?  # TODO
        trim: TrimData?  # TODO
        flags: ItemFlag[]? [] # TODO
        book: BookData?  # TODO
        color: LeatherArmorColor?  # TODO
        enchantments: {Enchantment: integer}? {} # TODO
ItemStackData: object?  # TODO
    properties: 
        type: Material? STONE # TODO
        amount: integer? 1 # TODO
        metadata: ItemMetaData?  # TODO
        quantity: integer? 1 # TODO
ItemStackWrapperEffect: object(superdoc = WrapperEffect, superdoc = Effect)?  # Acts like a trigger. \nTriggers for the item in the slot. \nThe item will be set to the item in the slot
    properties: 
        mode: enum! SELF # The mode of operation
            values: 
              - ALL
              - OTHER
              - SELF
        slot: InventorySlot? HAND # The slot of the item
        equipmentSlot: InventorySlot? HAND # The slot of the item
ItemWrapperCondition: object(superdoc = WrapperCondition, superdoc = Condition)?  # Checks if all inside conditions are true. \nThe item will be set as the item in the specified slot of the user or target entity
    properties: 
        mode: enum! SELF # The mode of operation
            values: 
              - ALL
              - OTHER
              - SELF
        slot: InventorySlot? HAND # The slot for the item
KillPotionData: object(superdoc = PotionEffectSkillData, superdoc = SkillData)?  # Applies a potion effect everytime the hero kills an entity
    properties: 
        entities: EntityType[]?  #
KnockbackEffect: object(superdoc = Effect)?  # Applies a velocity to the target entity in the direction that the user is looking as the direction
    properties: 
        mode: enum! OTHER # The mode of operation
            values: 
              - ALL
              - OTHER
        multiplier: Expression? 1.0 # The number to multiply the velocity by or set the velocity to. See `overwriteCurrentVelocity`
        overwriteCurrentVelocity: boolean? true # If true, sets the velocity. If false, multiplies original velocity
LanguageYaml: object?  # 
    properties: 
        config_version: string?  # TODO
        chatLanguageSettings: ChatLanguageSettings?  # TODO
        guiLanguageSettings: GUILanguageSettings?  # TODO
        Chat: ChatLanguageSettings?  # TODO
        GUI: GUILanguageSettings?  # TODO
LaunchEffect: object(superdoc = Effect)?  # Launches an entity. \nMode `OTHER`: Launched in the direction of the target entity. \nMode `SELF`: Launched in the direction the user is facing
    properties: 
        mode: enum! SELF # The mode of operation
            values: 
              - ALL
              - OTHER
              - SELF
        entity: EntityData? { type: \"FIREBALL\"} # The entity to launch
        velocity: Expression? 1.0 # The speed to launch at
LaunchProjectileSpell: object(superdoc = SpellData, superdoc = SkillData)?  # A spell that launches an entity in the direction the player is looking
    properties: 
        projectile: EntityData? {} # The entity to launch
LeatherArmorColor: object?  # TODO
    properties: 
        red: integer? -1 #
        green: integer? -1 #
        blue: integer? -1 #
LifestealData: object(superdoc = SkillData)?  # Gives a percentage of the damage dealt to an entity as health to the user, cannot exceed maximum hp
    properties: 
        lifestealPercentage: number? 5 # The percentage of damage that is given to the user as health
        lifestealpercentage: number? 5 # The percentage of damage that is given to the user as health
LightCondition: object(superdoc = Condition)?  # Checks the light level
    properties: 
        mode: enum! SELF # The mode of operation
            values: 
              - ALL
              - LOCATION
              - OTHER
              - SELF
        checkNatural: boolean? true # Whether to check for natural/sky light
        checkBlocks: boolean? true # Whether to check for block light
        lightRange: RangeData? -Infinity - Infinity # The range of light levels to compare against
        checkNaturalLight: boolean? true # Whether to check for natural/sky light
        checkBlockLight: boolean? true # Whether to check for block light
        light: RangeData? -Infinity - Infinity # The range of light levels to compare against
LightningEffect: object(superdoc = Effect)?  # Summons lightning on the user or target entity.
    properties: 
        mode: enum! SELF # The mode of operation
            values: 
              - ALL
              - OTHER
              - SELF
        fake: boolean? false # If true, it only makes the effect of lightning, not summoning an actual lightning
LightningSpell: object(superdoc = SpellData, superdoc = SkillData)! {} # A spell that summons lightning where the player is looking
LightSkillData: object(superdoc = PotionEffectSkillData, superdoc = SkillData)! {} # Applies a potion effect when the user is at a light level above 10
LivingEntityComponent: object(additionalProperties)?  # 
    properties: 
        canEquip: boolean? false #
        equipment: EquipmentData?  #
LlamaComponent: object(additionalProperties)?  # 
    properties: 
        color: Llama.Color?  # TODO
        strength: integer? 1 # TODO
LocationCubeEffect: object(superdoc = WrapperEffect, superdoc = Effect)?  # Acts like a trigger. \nTriggers for every location in the cube around the user or target entity. \nThe location will be set as the location the trigger triggers for
    properties: 
        mode: enum! SELF # The mode of operation
            values: 
              - ALL
              - LOCATION
              - OTHER
              - SELF
        verticalRadius: integer? 0 # Distance from the center to the vertical size of the cube
        horizontalRadius: integer? 0 # Distance from the center to the horizontal size of the cube
        offset: Vector? { x: 0, y: 0, z: 0 } # The offset from the original location
LocationOffsetEffect: object(superdoc = WrapperEffect, superdoc = Effect)?  # Acts like a trigger. \nTriggers the location of the user or target entity after being offseted. \nThe location will be set as the location the trigger triggers for
    properties: 
        mode: enum! SELF # The mode of operation
            values: 
              - ALL
              - LOCATION
              - OTHER
              - SELF
        offset: Vector? { x: 0, y: 0, z: 0 } # The offset from the original location
LoopData: object(superdoc = TriggerData)?  # Triggers periodically every couple of ticks
    properties: 
        period: Duration? 1.0 # TODO
LoseTargetEffect: object(superdoc = Effect)! {} # Make the user lose interest in the current target
    properties: 
        mode: enum! SELF # The mode of operation
            values: 
              - ALL
              - OTHER
              - SELF
LungeEffect: object(superdoc = Effect)?  # Applies an acceleration to the user or the target entity based on the direction the entity is looking
    properties: 
        mode: enum! SELF # The mode of operation
            values: 
              - ALL
              - OTHER
              - SELF
        horizontalVelocity: Expression? 0 # The scale to scale the horizontal components of the velocity vector
        verticalVelocity: Expression? 0 # The scale to scale the vertical components of the velocity vector
        overwrite: boolean? true # If true, sets the velocity vector. If false, adds to the velocity vector
MessageEffect: object(superdoc = Effect)?  # Sends a chat message to the user or target player
    properties: 
        mode: enum! SELF # The mode of operation
            values: 
              - ALL
              - OTHER
              - SELF
        message: ExpressiveMessage?  # The message to send
MetadataCondition: object(superdoc = ComparisonCondition, superdoc = Condition)?  # Compares a user defined variable
    properties: 
        mode: enum! SELF # The mode of operation
            values: 
              - ALL
              - OTHER
              - SELF
        variable: string!  # The variable to compare
MetadataEffect: object(superdoc = ModifyEffect, superdoc = Effect)?  # Modifies a user defined variable
    properties: 
        mode: enum! SELF # The mode of operation
            values: 
              - ALL
              - OTHER
              - SELF
        variable: string!  # The name of the variable
ModifyEffect: object(superdoc = Effect)?  # Modifies a variable, either user defined or not
    properties: 
        operation: ModifyEffect.Operation? SET # The operation to do
        value: Expression? 1 # The number on the right side of the operation
NearestEffect: object(superdoc = WrapperEffect, superdoc = Effect)?  # Acts like a trigger. \nTriggers for the nearest entity in the radius. \nThe target entity will be set as the nearest entity
    properties: 
        mode: enum! SELF # The mode of operation
            values: 
              - ALL
              - LOCATION
              - OTHER
              - SELF
        radius: number? 5 # The maximum distance to the entity
NoHungerData: object(superdoc = SkillData)?  # Makes the hero's hunger not go down after a certain level
    properties: 
        minimumHunger: number? 19 # TODO
NOTCondition: object(superdoc = Condition)?  # Inverts the inside condition
    properties: 
        mode: enum! SELF # The mode of operation
            values: 
              - ALL
              - ITEM
              - LOCATION
              - OTHER
              - SELF
        condition: Condition?  # The condition to invert
NPCCondition: object(superdoc = Condition)?  # Checks if the user or target entity is an npc
    properties: 
        mode: enum! SELF # The mode of operation
            values: 
              - ALL
              - OTHER
              - SELF
        npc: boolean? true # If true, checks if the entity is an npc. If false, it checks the opposite
        isNPC: boolean? true # If true, checks if the entity is an npc. If false, it checks the opposite
OHKOData: object(superdoc = SkillData)?  # Kills entities in one hit
    properties: 
        entityTypes: EntityType[]?  # The list of entities that can be killed in one hit
        displayName: string?  # The display name of the entity that can be killed in one hit. Any name will be killed in one hit if this is empty
        entitytypes: EntityType[]?  # The list of entities that can be killed in one hit
        displayname: string?  # The display name of the entity that can be killed in one hit. Any name will be killed in one hit if this is empty
OnGroundCondition: object(superdoc = Condition)?  # Checks if the user or target entity is on the ground
    properties: 
        mode: enum! SELF # The mode of operation
            values: 
              - ALL
              - OTHER
              - SELF
        grounded: boolean? true # If true, checks if the entity is on the ground. If false, it checks the opposite
        isGrounded: boolean? true # If true, checks if the entity is on the ground. If false, it checks the opposite
OptionsData: object?  # TODO
    properties: 
        colours: Color[]? [] # TODO
        scale: number? 1.0 # TODO
ORCondition: object(superdoc = Condition)?  # ORs all the conditions inside
    properties: 
        mode: enum! SELF # The mode of operation
            values: 
              - ALL
              - ITEM
              - LOCATION
              - OTHER
              - SELF
        conditions: ConditionList?  # The conditions to OR
ParticleData: object?  # TODO
    properties: 
        duration: number? 2.5 #
        particle: Particle? PORTAL #
        amount: integer? 1 #
        shape: Shape?  # undocumented#
        extra: number? 0 #
        options: OptionsData?  #
        numberOfParticles: integer? 1 #
ParticleEffect: object(superdoc = Effect)?  # Spawns particles
    properties: 
        mode: enum! SELF # The mode of operation
            values: 
              - ALL
              - LOCATION
              - OTHER
              - SELF
        particleData: ParticleData!  # The data of the particles to spawn
PermissionCondition: object(superdoc = Condition)?  # Checks whether the user or target entity has the command permission
    properties: 
        mode: enum! SELF # The mode of operation
            values: 
              - ALL
              - OTHER
              - SELF
        permission: string!  # The permission to check
PhaseData: object(superdoc = SkillData)?  # Allows the player to phase through the ground
    properties: 
        numberOfBlocksPhasingAboveWorldMinHeight: number? 5 # TODO
        minimumPhaseYAxis: number? 5 # TODO
PickpocketData: object(superdoc = SkillData)?  # Allows the hero to look at another player's inventory or drop a villager's inventory with right click
    properties: 
        range: number? 3 # The max distance to the other entity
        isSneaking: boolean? true # Whether the hero needs to be sneaking
        sneaking: boolean? true # Whether the hero needs to be sneaking
Pickup: object(superdoc = Effect)! {} # Pick up the target entity and places it on the user's head
    properties: 
        mode: enum! OTHER # The mode of operation
            values: 
              - ALL
              - OTHER
PlaceBlockEffect: object(superdoc = Effect)?  # Replaces a block at the location for an amount of time. Retains the original block data
    properties: 
        mode: enum! LOCATION # The mode of operation
            values: 
              - ALL
              - LOCATION
        blockData: BlockData!  # TODO
        updatePhysics: boolean? true # TODO
        isPacket: boolean? false # TODO
        revertConditions: ConditionList? {} # TODO
        revertsAfter: Expression? -1 # TODO
        block: BlockData!  # TODO
PlaceBlockSpell: object(superdoc = SpellData, superdoc = SkillData)?  # A spell that places a block
    properties: 
        block: BlockData?  #
PlayTrackEffect: object(superdoc = Effect)?  # 
    properties: 
        mode: enum! SELF # 
            values: 
              - ALL
              - OTHER
              - SELF
        song: Song?  #
        track: Song?  #
Point: object(superdoc = Shape)?  # 
    properties: 
        spread: number? 0 # TODO
        yOffset: number? 0 # TODO
        offset: number? 0 # TODO
Potion: object(superdoc = Effect)?  # Applies the potion effect to the user or target entity
    properties: 
        mode: enum! SELF # The mode of operation
            values: 
              - ALL
              - OTHER
              - SELF
        potionEffect: PotionEffectData!  # The potion effect
        potion: PotionEffectData!  # The potion effect
PotionEffectCondition: object(superdoc = Condition)?  # 
    properties: 
        mode: enum! SELF # The mode of operation
            values: 
              - ALL
              - OTHER
              - SELF
        effect: PotionEffectType!  # The type of potion to check. If not specified, it will check for any type of potion
        potency: RangeData? -Infinity - Infinity # The range of potion potency to check against
        duration: RangeData? -Infinity - Infinity # The range of potion duration to check against (in seconds)
PotionEffectData: object?  # TODO
    properties: 
        type: PotionEffectType!  #
        duration: number? 5 #
        potency: integer? 0 #
        ambient: boolean? true #
        hasParticles: boolean? true #
PotionEffectSkillData: object(superdoc = PotionEffectData, superdoc = SkillData)?  # 
PotionEffectTriggerData: object(superdoc = TriggerData)?  # Triggers when a potion effect is applied to the user
    properties: 
        types: PotionEffectType[]? [] # The potion effects that will trigger this trigger
        causes: EntityPotionEffectEvent.Cause[]?  # The list of potion effect causes to check (ex. ARROW, BEACON)
        actions: EntityPotionEffectEvent.Action[]?  # The list of potion effect actions to check (ex. ADDED, CHANGED)
PotionEntityComponent: object(additionalProperties)?  # 
    properties: 
        potion: ItemStack? SPLASH_POTION # TODO
PotionGifterSkillData: object(superdoc = PotionEffectSkillData, superdoc = SkillData)?  # 
    properties: 
        cooldown: number? 10 #
        receiverMessage: string? <grey><i>You have received a potion effect. #
        giverMessage: string? <grey><i>You gave them a potion effect. #
        cooldownMessage: string? <grey><i>You have <currentcooldown> seconds left until it can be used again! #
PotionMetaData: object?  # TODO
    properties: 
        type: PotionType? SWIFTNESS #
        extended: boolean? false #
        upgraded: boolean? false #
PowerOnStartSettings: object?  # 
    properties: 
        enabled: boolean!  # TODO
        isEnabled: boolean!  # TODO
        firstJoinTitle: boolean!  # TODO
        showHero: boolean!  # TODO
PrimedTntComponent: object(additionalProperties)?  # 
    properties: 
        fuseTicks: integer? 100 #
ProjectileData: object(superdoc = TriggerData)?  # Acts like the DAMAGEDBYPROJECTILE and DAMAGEDENTITYWITHPROJECTILE triggers combined
    properties: 
        onlyProjectiles: boolean? false # If true, will only trigger if the damaging entity is a projectile
ProjectileEffect: object(superdoc = Effect)?  # Shoots an entity from the user. \nMode `SELF`: Shoots in the direction that the user is looking. \nMode `OTHER`: Shoots at the target entity. \nMode `LOCATION`: Shoots at the location
    properties: 
        mode: enum! SELF # The mode of operation
            values: 
              - ALL
              - LOCATION
              - OTHER
              - SELF
        projectile: EntityData? { type: \"SNOWBALL\"} # The entity to shoot
        velocity: number? 1.0 # The shooting velocity
RabbitComponent: object(additionalProperties)?  # 
    properties: 
        variant: Rabbit.Type?  # TODO
RandomTeleportEffect: object(superdoc = Effect)?  # Teleports the user or target entity a random distance
    properties: 
        mode: enum! SELF # The mode of operation
            values: 
              - ALL
              - OTHER
              - SELF
        maxDistance: number? 10 # The maximum distance
        minDistance: number? 5 # The minimum distance
RaytraceEffect: object(superdoc = WrapperEffect, superdoc = Effect)?  # Acts like a trigger. \nSends out a raytrace that collides with entities or blocks in the direction that the user or target entity is looking. \nThe target entity will be set as the collided entity. \nThe location will be set as the location of the collided block
    properties: 
        mode: enum! SELF # The mode of operation
            values: 
              - ALL
              - OTHER
              - SELF
        maxDistance: number? 10 # The maximum distance the raytrace can collide
        collisionMode: FluidCollisionMode? NEVER # The collision behavior when a fluid gets hit by the raytrace
        ignorePassables: boolean? true # Whether to ignore passable blocks (ex. tall grass, signs, fluids)
        alwaysHit: boolean? true # If true, if the raytrace does not hit anything, the location will be set as the maxDistance in the direction the user is looking
        raySize: number? 1.0 # The collision size of the ray
        raysize: number? 1.0 # The collision size of the ray
RemoteDetonationData: object(superdoc = CooldownData, superdoc = SkillData)?  # Creates an explosion at the entity the user is looking at when the user sneaks
    properties: 
        spawnsFire: boolean? false # If true, explosion will spawn fire
        breakBlocks: boolean? true # If true, the explosion will break blocks
        removeDetonatedEntity: boolean? true # If true, the entity that was detonated will be removed
        explosionStrength: number? 1 # The strength of the explosion
        explodable: EntityType[]? [] # The types of entities that can be exploded
RemoveEntityEffect: object(superdoc = Effect)! {} # Removes the user or target entity
    properties: 
        mode: enum! SELF # The mode of operation
            values: 
              - ALL
              - OTHER
              - SELF
RemovePotionEffect: object(superdoc = Effect)?  # Removes potion effects from the user or target entity
    properties: 
        mode: enum! SELF # The mode of operation
            values: 
              - ALL
              - OTHER
              - SELF
        types: PotionEffectType[]? [] # The list of potion types. If empty, removes all potion effect
RepulseEffect: object(superdoc = Effect)?  # Repulse the target entity
    properties: 
        mode: enum! OTHER # The mode of operation
            values: 
              - ALL
              - OTHER
        velocity: number? 1.0 # The speed to repulse the target entity. Positive value means away from the user. Negative value means into the user
        add: boolean? false # Whether to add velocity or set it
RepulsionData: object(superdoc = SkillData)?  # Repulses all nearby entities when the user sneaks
    properties: 
        multiplier: number? 1 # The multiplier for the repulsion
        radius: number? 5.0 # The radius where inside entities are effected
        entities: EntityType[]? [] # The list of entities to blacklist/whitelist
        whitelist: boolean? false # Whether entities is a whitelist or a blacklist
        entityBlacklist: EntityType[]? [] # The list of entities to blacklist/whitelist
        blacklist: EntityType[]? [] # The list of entities to blacklist/whitelist
RerollConfig: object?  # TODO
    properties: 
        configVersion: string?  # TODO
        globalRerollSettings: GlobalRerollSettings?  # default# # TODO
        rerollGroups: RerollGroup{}? {} # TODO
        config_version: string?  # TODO
        global_reroll_settings: GlobalRerollSettings?  # default# # TODO
        reroll_groups: RerollGroup{}? {} # TODO
RerollGroup: object?  # TODO
    properties: 
        weightedHeroes: RerollGroup.WeightedHero[]? [] #
        itemComparator: ItemComparisonData?  #
        heroes: RerollGroup.WeightedHero[]? [] #
        item: ItemComparisonData?  #
RerollGroup.WeightedHero: object?  # 
    properties: 
        hero: string!  # TODO
        weight: integer!  # TODO
ResizeEffect: object(superdoc = ModifyEffect, superdoc = Effect)?  # Resizes the user or target entity (for slimes, magma cubes, and phantoms)
    properties: 
        mode: enum! SELF # The mode of operation
            values: 
              - ALL
              - OTHER
              - SELF
        retainHealth: boolean? true # For slimes and magma cubes. If true, make the entity retain the previous health, if more than the new max health, it sets it to the new max health
ScrambleInventoryEffect: object(superdoc = Effect)! {} # Scrambles the inventory of the user or target entity
    properties: 
        mode: enum! SELF # The mode of operation
            values: 
              - ALL
              - OTHER
              - SELF
ShapedRecipeData: object?  # TODO
    properties: 
        recipe: string[]! [] # TODO
        recipeKeys: {Material: string}! {} # TODO
        result: ItemStack!  # TODO
        uniqueKey: string!  # TODO
        unique_key: string!  # TODO
ShapelessRecipeData: object?  # TODO
    properties: 
        result: ItemStack!  #
        ingredients: {Material: integer}! {} #
        uniqueKey: string!  #
        unique_key: string!  #
ShieldData: object(superdoc = SkillData)?  # Sets the shields cooldown when the user take damage
    properties: 
        cooldown: Duration? 100.0 #
ShieldedCondition: object(superdoc = Condition)! {} # Checks if the user is blocking
    properties: 
        mode: enum! SELF # The mode of operation
            values: 
              - ALL
              - SELF
ShooterCondition: object(superdoc = Condition)! {} # Checks whether the shooter of the `OTHER` entity is the `SELF` entity
    properties: 
        mode: enum! OTHER # The mode of operation
            values: 
              - ALL
              - OTHER
ShooterEffect: object(superdoc = WrapperEffect, superdoc = Effect)?  # Acts like a trigger. \nTriggers for the target entity. \nThe new target entity will be set as the source of the projectile if the old target entity is a projectile, otherwise the target entity will remain the same
    properties: 
        mode: enum! OTHER # The mode of operation
            values: 
              - ALL
              - OTHER
        onlyProjectiles: boolean? true # If true, only triggers if the original target entity is a projectile. If false, keep the target entity the same
SizeComponent: object(additionalProperties)?  # 
    properties: 
        size: integer?  # TODO
SizeCondition: object(superdoc = Condition)?  # Checks if the size of the user or target entity is in the range (for slimes, magma cubes, and phantoms)
    properties: 
        mode: enum! SELF # The mode of operation
            values: 
              - ALL
              - OTHER
              - SELF
        size: RangeData? -Infinity - Infinity # The range of sizes
Skill: object?  # A skill
    properties: 
        trigger: TriggerData!  # What triggers this skill
        effects: EffectList!  # The list of effects to run
        conditions: ConditionList!  # The condition that the effects will run
Skin: object?  # 
    properties: 
        value: string?  # TODO
        signature: string?  # TODO
SlamData: object(superdoc = CooldownData, superdoc = SkillData)?  # Allows the player to jump high up in the air and do a slam, damaging entities near the impact\nTriggered with punch
    properties: 
        hand: ItemStack? AIR # The item that has to be in hand to perform this skill
        airCooldown: number? 1 # Cooldown from the start of the slam
        foodCost: integer? 0 # How much food points/hunger this takes
        minimumFood: integer? 0 # The minimum food points needed to perform this skill
        radius: number? 5 # The horizontal radius where entities inside the radius will be damaged
        damage: number? 0 # The amount of damage this skill will do
        item: ItemStack? AIR # The item that has to be in hand to perform this skill
        diameterRadius: number? 5 # The horizontal radius where entities inside the radius will be damaged
SlimeData: object(superdoc = SkillData)?  # Let's the hero bounce around like a slime, also adds horizontal velocity in the direction the player is facing
    properties: 
        speedMultiplier: number? 1 # The horizontal speed
SneakCondition: object(superdoc = Condition)?  # Checks if the player or entity is shifting
    properties: 
        mode: enum! SELF # The mode of operation
            values: 
              - ALL
              - OTHER
              - SELF
        sneak: boolean? true # If true, checks if the entity is shifting. If false, it checks the opposite
SneakData: object(superdoc = SkillData)?  # Prevents being targeted by entities
    properties: 
        mustSneak: boolean?  #
        needsInvisibility: boolean?  #
        sneak: boolean?  #
SneakingPotionData: object(superdoc = PotionEffectData, superdoc = SkillData)?  # 
SoundData: object?  # TODO
    properties: 
        sound: Sound? ENTITY_GENERIC_EXPLODE #
        volume: number? 1.0 #
        pitch: number? 1.0 #
SoundEffect: object(superdoc = Effect)?  # Plays a sound at the location or at the location of the user or target entity
    properties: 
        mode: enum! SELF # The mode of operation
            values: 
              - ALL
              - LOCATION
              - OTHER
              - SELF
        sound: SoundData?  # The sound data
SpawnEffect: object(superdoc = Effect)?  # Spawns an entity at the location or the location of the user or target entity
    properties: 
        mode: enum! SELF # The mode of operation
            values: 
              - ALL
              - LOCATION
              - OTHER
              - SELF
        entity: EntityData? { type: \"ZOMBIE\"} # The entity to spawn
SpectralArrowComponent: object(additionalProperties, superdoc = AbstractArrowComponent)?  # 
    properties: 
        glowingTicks: integer? 200 #
SpeedCondition: object(superdoc = Condition)?  # Checks whether the speed of the user or target entity is in the range
    properties: 
        mode: enum! SELF # The mode of operation
            values: 
              - ALL
              - OTHER
              - SELF
        speedRange: RangeData?  # The speed range to check againts
        speed: RangeData?  # The speed range to check againts
SprintingCondition: object(superdoc = Condition)! {} # Checks if the user or target entity is sprinting
    properties: 
        mode: enum! SELF # The mode of operation
            values: 
              - ALL
              - OTHER
              - SELF
StrongmanData: object(superdoc = SkillData)?  # 
    properties: 
        velocity: number? 2.5 # The horizontal speed to throw the entity
        upwardsVelocity: number? 1 # The upward velocity to throw the entity
        tooMuscularMessage: string? <player> <white> is too strong to sit in a vehicle! # The message to give to the player when the player attempts to sit in a vehicle\n\n\"<player>\" will be replaced by the name of the player\n
        maxPassengers: integer? 10 # The maximum number of entities that can be picked up at once
        upwardsvelocity: number? 1 # The upward velocity to throw the entity
        toomuscularmessage: string? <player> <white> is too strong to sit in a vehicle! # The message to give to the player when the player attempts to sit in a vehicle\n\n\"<player>\" will be replaced by the name of the player\n
        maxpassengers: integer? 10 # The maximum number of entities that can be picked up at once
SummonSkillData: object(superdoc = PotionEffectSkillData, superdoc = SkillData)?  # On punch with an empty hand, summons an entity where the player is looking
    properties: 
        range: integer? 10 # The max distance in blocks the entity will be summoned\nIf the player is looking at something out of range, it will summon this many blocks away
        repel: boolean? false # Whether to repel the player when summoning
        mustSneak: boolean? true # Whether the player must be sneaking
        entity: EntityType? LIGHTNING_BOLT # The entity to spawn
        action: Action[]?  # undocumented# # The actions that will trigger the summoning
        cooldown: number? 10.0 # The cooldown in seconds
        cooldownMessage: string? <white>Cooldown: <currentcooldown> seconds # The cooldown message to the player when the cooldown isn't over yet\n\n\"<currentcooldown>\" will be replaced with the current cooldown in seconds\n
        sneak: boolean? true # Whether the player must be sneaking
        mustsneak: boolean? true # Whether the player must be sneaking
        entityType: EntityType? LIGHTNING_BOLT # The entity to spawn
Superhero: object(additionalProperties)?  # TODO
    properties: 
        name: string?  # TODO
        colouredName: string?  # TODO
        description: string?  # TODO
        heroGainedSound: SoundData?  # TODO
        skin: Skin?  # TODO
        icon: ItemStack?  # TODO
        skills: SkillsContainer? {} # TODO
        plusUltraSkills: PlusUltraSkillsContainer? {} # TODO
SuperheroCondition: object(superdoc = Condition)?  # Checks the hero against a list of heroes
    properties: 
        mode: enum! SELF # The mode of operation
            values: 
              - ALL
              - OTHER
              - SELF
        heroes: string[]!  # TODO
SwapEffect: object(superdoc = Effect)! {} # Swaps the position of the user and target entity
    properties: 
        mode: enum! OTHER # The mode of operation
            values: 
              - ALL
              - OTHER
SwimmingCondition: object(superdoc = Condition)! {} # Checks if the user or target entity is swimming
    properties: 
        mode: enum! SELF # The mode of operation
            values: 
              - ALL
              - OTHER
              - SELF
SwitcherooWrapperEffect: object(superdoc = WrapperEffect, superdoc = Effect)! {} # Acts like a trigger. \nThe target entity will be set as the original user.\n the user will be set as the original target entity
    properties: 
        mode: enum! OTHER # The mode of operation
            values: 
              - ALL
              - OTHER
TamedCondition: object(superdoc = Condition)?  # Checks if the target entity is tamed
    properties: 
        mode: enum! OTHER # The mode of operation
            values: 
              - ALL
              - OTHER
        checkOwner: boolean? true # If true, also checks if the user is the owner
TargetEntityEffect: object(superdoc = Effect)! {} # If the user is a mob, sets the target of the user to the target entity
    properties: 
        mode: enum! OTHER # The mode of operation
            values: 
              - ALL
              - OTHER
TeleportData: object(superdoc = CooldownData, superdoc = SkillData)?  # Teleports the player in the direction that they are looking at
    properties: 
        actions: Action[]?  # undocumented# # The set of actions that trigger this skill
        distance: integer? 30 # The max distance to teleport
        yAxisMultiplier: number? 1 #
        teleportCause: PlayerTeleportEvent.TeleportCause? ENDER_PEARL # The cause of this teleport will be set to this value
        particle: ParticleData?  # The particles to add after teleportation
        teleportItem: ItemComparisonData?  # undocumented# # The item that has to be in hand to teleport
        action: Action[]?  # undocumented# # The set of actions that trigger this skill
TeleportEffect: object(superdoc = Effect)! {} # Teleports the user to the location or the location of the target entity
    properties: 
        mode: enum! OTHER # The mode of operation
            values: 
              - ALL
              - LOCATION
              - OTHER
TemperatureCondition: object(superdoc = Condition)?  # Checks if the location or the location of the user or target entity is in the range
    properties: 
        mode: enum! SELF # The mode of operation
            values: 
              - ALL
              - LOCATION
              - OTHER
              - SELF
        temperatureRange: RangeData?  # The range of temperature, from -1 to 1
        temperature: RangeData?  # The range of temperature, from -1 to 1
ThrowableProjectileComponent: object(additionalProperties)?  # 
    properties: 
        itemStackData: ItemStackData?  # TODO
ThrowerData: object(superdoc = CooldownData, superdoc = SkillData)?  # Throws an entity in the direction the player is looking
    properties: 
        ammoCost: integer? 1 # How much ammo is consumed per throw
        ammo: ItemComparisonData? {} # The item that is consumed as ammo per throw
        projectile: EntityType? SNOWBALL # The entity that is thrown
        actions: Action[]?  # undocumented# # The actions that trigger the throw
        canPickUp: boolean? false # Whether the projectile can be picked up by the player. Only for arrows and tridents
        velocity: number? 1.4 # The speed of the projectile
        damage: number? 3 # The damage of the projectile. Only for arrows and tridents
        item: ItemComparisonData? {} # The item that is consumed as ammo per throw
TimeCondition: object(superdoc = Condition)?  # Checks the relative in-game time (time of day) of the world that the player is in against the range. Measured in milli-hours or hours*1000
    properties: 
        mode: enum! SELF # The mode of operation
            values: 
              - ALL
              - SELF
        time: RangeData? -Infinity - Infinity # A range for time
TimerEffect: object(superdoc = WrapperEffect, superdoc = Effect)?  # Acts like a trigger. \nTriggers for a number of times with a period and initial delay. \nTarget items will be forwarded
    properties: 
        mode: enum! SELF # The mode of operation
            values: 
              - ALL
              - ITEM
              - LOCATION
              - OTHER
              - SELF
        ticksDelay: Duration? 1.0 # The initial delay in seconds (1 is 20 ticks)
        period: Duration? 1.0 # The delay between triggers in seconds (1 is 20 ticks)
        repeats: integer? 1 # The number of times this trigger will trigger
        delay: Duration? 1.0 # The initial delay in seconds (1 is 20 ticks)
        numberOfRepeats: integer? 1 # The number of times this trigger will trigger
TransmutationSpell: object(superdoc = SpellData, superdoc = SkillData)?  # A spell that replaces blocks
    properties: 
        transmutableBlocks: Material[]? [] # The list of blocks that can be replaced
        block: BlockData?  # undocumented# # The resulting block
        resultantBlock: BlockData?  # undocumented# # The resulting block
TrimData: object?  # TODO
    properties: 
        pattern: TrimPattern!  #
        material: TrimMaterial!  #
Vector: object! {x: 0, y: 0, z: 0} # 
    properties: 
        x: number!  #
        y: number!  #
        z: number!  #
VeinMinerEffect: object(superdoc = Effect)?  # Breaks surrounding blocks around a location recursively
    properties: 
        mode: enum! LOCATION # The mode of operation
            values: 
              - ALL
              - LOCATION
        materials: Material[]? [] # The list of types that can be broken
        delay: Duration? 0.05 # The delay between each break in seconds (1 is 20 ticks)
        limit: integer? 10 # The max recursion depth ie. the radius from the start
        allowMultiTypeVein: boolean? false # If true, the vein will break all types in the list instead of only breaking the same type of block as the one in original location
        types: Material[]? [] # The list of types that can be broken
VelocityEffect: object(superdoc = ModifyEffect, superdoc = Effect)?  # Modifies the velocity of the user or target entity. Same as FLING
    properties: 
        mode: enum! SELF # The mode of operation
            values: 
              - ALL
              - OTHER
              - SELF
        component: string? Y # The component(s) to modify, `ALL` means all components (ex. `XZ` would only modify the X and Z velocities and leave Y unmodified)
VisibilityCondition: object(superdoc = Condition)?  # Checks if the user has a direct line of sight to the target entity
    properties: 
        mode: enum! OTHER # The mode of operation
            values: 
              - ALL
              - OTHER
        maxDistance: number? 16 # The maximum distance to the target entity
        distance: number? 16 # The maximum distance to the target entity
WaitEffect: object(superdoc = WrapperEffect, superdoc = Effect)?  # Acts like a trigger. \nWaits a duration of time before it triggers
    properties: 
        mode: enum! SELF # The mode of operation
            values: 
              - ALL
              - ITEM
              - LOCATION
              - OTHER
              - SELF
        ticksDelay: Duration? 20.0 # The delay time in seconds (1 is 20 ticks)
        delay: Duration? 20.0 # The delay time in seconds (1 is 20 ticks)
WalkerData: object(superdoc = SkillData)?  # Places blocks below the player
    properties: 
        blocksToPlace: Material[]? [] # The blocks to place
        blocksToReplace: Material[]? [] # The blocks that can be replaced
        blocksToPlaceOn: Material[]? [] # The blocks that has to be below the block this skill places
        isSneaking: boolean? false # Whether the player must be sneaking for this skill to work
        blocksDrop: boolean? true # Whether the blocks placed by this skill can drop block drops
        shouldRevert: boolean? false # Whether the blocks placed by this skill revert to the original block
        aboveFloor: boolean? false # Whether the blocks will be placed on the player or below them
        canPlaceFloating: boolean? true # Whether the block can be placed if it is air below
        revertsAfter: Duration? 15.0 # The time it takes for the blocks to revert in seconds
        sneaking: boolean? false # Whether the player must be sneaking for this skill to work
        issneaking: boolean? false # Whether the player must be sneaking for this skill to work
WeatherCondition: object(superdoc = Condition)! {} # Checks if the world that the user is in has a storm
    properties: 
        mode: enum! SELF # The mode of operation
            values: 
              - ALL
              - LOCATION
              - SELF
WeatherDamageData: object(superdoc = SkillData)?  # Makes the player take damage every  when it's raining
    properties: 
        damage: number? 1.0 # The damage that is dealt
        checkShelter: boolean? true # Whether to check if there's a block above and not deal the damage if there is
Wings: object?  # 
Wisp: object(superdoc = Shape)?  # 
    properties: 
        radius: number? 0.5 #
        speed: number? 1 #
        waveFrequency: number? 1 #
        height: number? 2 #
        wave_frequency: number? 1 #
WitherSkullComponent: object(additionalProperties)?  # 
    properties: 
        isCharged: boolean? false #
WolfComponent: object(additionalProperties)?  # 
    properties: 
        angry: boolean? false #
WorldCondition: object(superdoc = Condition)?  # Checks if the world that the user, target entity, or location is in is one of the listed worlds
    properties: 
        mode: enum! SELF # The mode of operation
            values: 
              - ALL
              - LOCATION
              - OTHER
              - SELF
        worlds: string[]? [] # TODO
WrapperCondition: object(superdoc = Condition)?  # Checks if all inside conditions are true
    properties: 
        conditions: ConditionList? {} # The conditions to check
WrapperEffect: object(superdoc = Effect)?  # Acts like a trigger
    properties: 
        conditions: ConditionList? {} # The list of conditions
        effects: EffectList? {} # The list of effects
ZombifiableComponent: object(additionalProperties)?  # 
    properties: 
        immuneToZombification: boolean? false # TODO
AbstractArrow.PickupStatus: enum?  # TODO
    values: 
      - ALLOWED
      - CREATIVE_ONLY
      - DISALLOWED
AbstractHorse: enum!  # 
    values: 
      - CAMEL
      - DONKEY
      - HORSE
      - LLAMA
      - MULE
      - SKELETON_HORSE
      - TRADER_LLAMA
      - ZOMBIE_HORSE
Action: enum?  # TODO
    values: 
      - LEFT_CLICK_AIR
      - LEFT_CLICK_BLOCK
      - PHYSICAL
      - RIGHT_CLICK_AIR
      - RIGHT_CLICK_BLOCK
Ageable: enum!  # 
    values: 
      - ARMADILLO
      - AXOLOTL
      - BEE
      - CAMEL
      - CAT
      - CHICKEN
      - COW
      - DOLPHIN
      - DONKEY
      - DROWNED
      - FOX
      - FROG
      - GLOW_SQUID
      - GOAT
      - HOGLIN
      - HORSE
      - HUSK
      - LLAMA
      - MOOSHROOM
      - MULE
      - OCELOT
      - PANDA
      - PARROT
      - PIG
      - PIGLIN
      - PIGLIN_BRUTE
      - POLAR_BEAR
      - RABBIT
      - SHEEP
      - SKELETON_HORSE
      - SNIFFER
      - SQUID
      - STRIDER
      - TRADER_LLAMA
      - TURTLE
      - VILLAGER
      - WANDERING_TRADER
      - WOLF
      - ZOGLIN
      - ZOMBIE
      - ZOMBIE_HORSE
      - ZOMBIE_VILLAGER
      - ZOMBIFIED_PIGLIN
Arrow: enum!  # 
    values: 
      - ARROW
Attribute: enum!  # 
    values: 
      - armor
      - armor_toughness
      - attack_damage
      - attack_knockback
      - attack_speed
      - block_break_speed
      - block_interaction_range
      - burning_time
      - entity_interaction_range
      - explosion_knockback_resistance
      - fall_damage_multiplier
      - flying_speed
      - follow_range
      - gravity
      - jump_strength
      - knockback_resistance
      - luck
      - max_absorption
      - max_health
      - mining_efficiency
      - movement_efficiency
      - movement_speed
      - oxygen_bonus
      - safe_fall_distance
      - scale
      - sneaking_speed
      - spawn_reinforcements
      - step_height
      - submerged_mining_speed
      - sweeping_damage_ratio
      - tempt_range
      - water_movement_efficiency
AttributesData.Operation: enum?  # TODO
    values: 
      - ADD_NUMBER
      - ADD_SCALAR
      - MULTIPLY_SCALAR
      - MULTIPLY_SCALAR_1
Axolotl: enum!  # 
    values: 
      - AXOLOTL
Axolotl.Variant: enum?  # TODO
    values: 
      - BLUE
      - CYAN
      - GOLD
      - LUCY
      - WILD
Biome: enum!  # 
    values: 
      - BADLANDS
      - BAMBOO_JUNGLE
      - BASALT_DELTAS
      - BEACH
      - BIRCH_FOREST
      - CHERRY_GROVE
      - COLD_OCEAN
      - CRIMSON_FOREST
      - DARK_FOREST
      - DEEP_COLD_OCEAN
      - DEEP_DARK
      - DEEP_FROZEN_OCEAN
      - DEEP_LUKEWARM_OCEAN
      - DEEP_OCEAN
      - DESERT
      - DRIPSTONE_CAVES
      - END_BARRENS
      - END_HIGHLANDS
      - END_MIDLANDS
      - ERODED_BADLANDS
      - FLOWER_FOREST
      - FOREST
      - FROZEN_OCEAN
      - FROZEN_PEAKS
      - FROZEN_RIVER
      - GROVE
      - ICE_SPIKES
      - JAGGED_PEAKS
      - JUNGLE
      - LUKEWARM_OCEAN
      - LUSH_CAVES
      - MANGROVE_SWAMP
      - MEADOW
      - MUSHROOM_FIELDS
      - NETHER_WASTES
      - OCEAN
      - OLD_GROWTH_BIRCH_FOREST
      - OLD_GROWTH_PINE_TAIGA
      - OLD_GROWTH_SPRUCE_TAIGA
      - PALE_GARDEN
      - PLAINS
      - RIVER
      - SAVANNA
      - SAVANNA_PLATEAU
      - SMALL_END_ISLANDS
      - SNOWY_BEACH
      - SNOWY_PLAINS
      - SNOWY_SLOPES
      - SNOWY_TAIGA
      - SOUL_SAND_VALLEY
      - SPARSE_JUNGLE
      - STONY_PEAKS
      - STONY_SHORE
      - SUNFLOWER_PLAINS
      - SWAMP
      - TAIGA
      - THE_END
      - THE_VOID
      - WARM_OCEAN
      - WARPED_FOREST
      - WINDSWEPT_FOREST
      - WINDSWEPT_GRAVELLY_HILLS
      - WINDSWEPT_HILLS
      - WINDSWEPT_SAVANNA
      - WOODED_BADLANDS
BlockFace: enum?  # TODO
    values: 
      - DOWN
      - EAST
      - EAST_NORTH_EAST
      - EAST_SOUTH_EAST
      - NORTH
      - NORTH_EAST
      - NORTH_NORTH_EAST
      - NORTH_NORTH_WEST
      - NORTH_WEST
      - SELF
      - SOUTH
      - SOUTH_EAST
      - SOUTH_SOUTH_EAST
      - SOUTH_SOUTH_WEST
      - SOUTH_WEST
      - UP
      - WEST
      - WEST_NORTH_WEST
      - WEST_SOUTH_WEST
BlockRayMode: enum?  # TODO
    values: 
      - ABOVEBLOCK
      - CLOSERBLOCK
      - THEBLOCK
ChestedHorse: enum!  # 
    values: 
      - DONKEY
      - LLAMA
      - MULE
      - TRADER_LLAMA
Colorable: enum!  # 
    values: 
      - SHEEP
      - SHULKER
CommandEffect.Executor: enum?  # TODO
    values: 
      - CONSOLE
      - PLAYER
ComparisonCondition.Comparison: enum!  # TODO
    values: 
      - EQUAL
      - GREATER
      - GREATEREQUAL
      - LESS
      - LESSEQUAL
Creeper: enum!  # 
    values: 
      - CREEPER
DyeColor: enum?  # TODO
    values: 
      - BLACK
      - BLUE
      - BROWN
      - CYAN
      - GRAY
      - GREEN
      - LIGHT_BLUE
      - LIGHT_GRAY
      - LIME
      - MAGENTA
      - ORANGE
      - PINK
      - PURPLE
      - RED
      - WHITE
      - YELLOW
Enchantment: enum!  # 
    values: 
      - aqua_affinity
      - bane_of_arthropods
      - binding_curse
      - blast_protection
      - breach
      - channeling
      - density
      - depth_strider
      - efficiency
      - feather_falling
      - fire_aspect
      - fire_protection
      - flame
      - fortune
      - frost_walker
      - impaling
      - infinity
      - knockback
      - looting
      - loyalty
      - luck_of_the_sea
      - lure
      - mending
      - multishot
      - piercing
      - power
      - projectile_protection
      - protection
      - punch
      - quick_charge
      - respiration
      - riptide
      - sharpness
      - silk_touch
      - smite
      - soul_speed
      - sweeping_edge
      - swift_sneak
      - thorns
      - unbreaking
      - vanishing_curse
      - wind_burst
EntityDamageEvent.DamageCause: enum?  # TODO
    values: 
      - BLOCK_EXPLOSION
      - CAMPFIRE
      - CONTACT
      - CRAMMING
      - CUSTOM
      - DRAGON_BREATH
      - DROWNING
      - DRYOUT
      - ENTITY_ATTACK
      - ENTITY_EXPLOSION
      - ENTITY_SWEEP_ATTACK
      - FALL
      - FALLING_BLOCK
      - FIRE
      - FIRE_TICK
      - FLY_INTO_WALL
      - FREEZE
      - HOT_FLOOR
      - KILL
      - LAVA
      - LIGHTNING
      - MAGIC
      - MELTING
      - POISON
      - PROJECTILE
      - SONIC_BOOM
      - STARVATION
      - SUFFOCATION
      - SUICIDE
      - THORNS
      - VOID
      - WITHER
      - WORLD_BORDER
EntityPotionEffectEvent.Action: enum?  # TODO
    values: 
      - ADDED
      - CHANGED
      - CLEARED
      - REMOVED
EntityPotionEffectEvent.Cause: enum?  # TODO
    values: 
      - AREA_EFFECT_CLOUD
      - ARROW
      - ATTACK
      - AXOLOTL
      - BEACON
      - COMMAND
      - CONDUIT
      - CONVERSION
      - DEATH
      - DOLPHIN
      - EXPIRATION
      - FOOD
      - ILLUSION
      - MILK
      - PATROL_CAPTAIN
      - PLUGIN
      - POTION_DRINK
      - POTION_SPLASH
      - SPIDER_SPAWN
      - TOTEM
      - TURTLE_HELMET
      - UNKNOWN
      - VILLAGER_TRADE
      - WARDEN
      - WITHER_ROSE
EntityType: enum!  # 
EquipmentSlot: enum? HAND # 
    values: 
      - BODY
      - CHEST
      - FEET
      - HAND
      - HEAD
      - LEGS
      - OFF_HAND
EquipmentSlotGroup: enum? ANY # 
    values: 
      - ANY
      - ARMOR
      - CHEST
      - FEET
      - HAND
      - HEAD
      - LEGS
      - MAINHAND
      - OFFHAND
ExperienceOrb: enum!  # 
    values: 
      - EXPERIENCE_ORB
Explosive: enum!  # 
    values: 
      - BREEZE_WIND_CHARGE
      - DRAGON_FIREBALL
      - FIREBALL
      - SMALL_FIREBALL
      - TNT
      - TNT_MINECART
      - WIND_CHARGE
      - WITHER_SKULL
FallingBlock: enum!  # 
    values: 
      - FALLING_BLOCK
FluidCollisionMode: enum?  # TODO
    values: 
      - ALWAYS
      - NEVER
      - SOURCE_ONLY
Hoglin: enum!  # 
    values: 
      - HOGLIN
Horse: enum!  # 
    values: 
      - HORSE
Horse.Color: enum?  # TODO
    values: 
      - BLACK
      - BROWN
      - CHESTNUT
      - CREAMY
      - DARK_BROWN
      - GRAY
      - WHITE
Horse.Style: enum?  # TODO
    values: 
      - BLACK_DOTS
      - NONE
      - WHITE
      - WHITEFIELD
      - WHITE_DOTS
Item: enum!  # 
    values: 
      - ITEM
ItemFlag: enum?  # TODO
    values: 
      - HIDE_ADDITIONAL_TOOLTIP
      - HIDE_ARMOR_TRIM
      - HIDE_ATTRIBUTES
      - HIDE_DESTROYS
      - HIDE_DYE
      - HIDE_ENCHANTS
      - HIDE_PLACED_ON
      - HIDE_UNBREAKABLE
LivingEntity: enum!  # 
    values: 
      - ALLAY
      - ARMADILLO
      - ARMOR_STAND
      - AXOLOTL
      - BAT
      - BEE
      - BLAZE
      - BOGGED
      - BREEZE
      - CAMEL
      - CAT
      - CAVE_SPIDER
      - CHICKEN
      - COD
      - COW
      - CREAKING
      - CREEPER
      - DOLPHIN
      - DONKEY
      - DROWNED
      - ELDER_GUARDIAN
      - ENDERMAN
      - ENDERMITE
      - ENDER_DRAGON
      - EVOKER
      - FOX
      - FROG
      - GHAST
      - GIANT
      - GLOW_SQUID
      - GOAT
      - GUARDIAN
      - HOGLIN
      - HORSE
      - HUSK
      - ILLUSIONER
      - IRON_GOLEM
      - LLAMA
      - MAGMA_CUBE
      - MOOSHROOM
      - MULE
      - OCELOT
      - PANDA
      - PARROT
      - PHANTOM
      - PIG
      - PIGLIN
      - PIGLIN_BRUTE
      - PILLAGER
      - PLAYER
      - POLAR_BEAR
      - PUFFERFISH
      - RABBIT
      - RAVAGER
      - SALMON
      - SHEEP
      - SHULKER
      - SILVERFISH
      - SKELETON
      - SKELETON_HORSE
      - SLIME
      - SNIFFER
      - SNOW_GOLEM
      - SPIDER
      - SQUID
      - STRAY
      - STRIDER
      - TADPOLE
      - TRADER_LLAMA
      - TROPICAL_FISH
      - TURTLE
      - VEX
      - VILLAGER
      - VINDICATOR
      - WANDERING_TRADER
      - WARDEN
      - WITCH
      - WITHER
      - WITHER_SKELETON
      - WOLF
      - ZOGLIN
      - ZOMBIE
      - ZOMBIE_HORSE
      - ZOMBIE_VILLAGER
      - ZOMBIFIED_PIGLIN
Llama: enum!  # 
    values: 
      - LLAMA
      - TRADER_LLAMA
Llama.Color: enum?  # TODO
    values: 
      - BROWN
      - CREAMY
      - GRAY
      - WHITE
Material: enum!  # 
Mode: enum?  # A mode of operation for conditions and effects
    values: 
      - ALL
      - ITEM
      - LOCATION
      - OTHER
      - SELF
ModifyEffect.Operation: enum?  # TODO
    values: 
      - ADD
      - DIVIDE
      - MULTIPLY
      - SET
      - SUBTRACT
Particle: enum!  # 
Phantom: enum!  # 
    values: 
      - PHANTOM
PiglinAbstract: enum!  # 
    values: 
      - PIGLIN
      - PIGLIN_BRUTE
PlayerTeleportEvent.TeleportCause: enum?  # TODO
    values: 
      - CHORUS_FRUIT
      - COMMAND
      - DISMOUNT
      - ENDER_PEARL
      - END_GATEWAY
      - END_PORTAL
      - EXIT_BED
      - NETHER_PORTAL
      - PLUGIN
      - SPECTATE
      - UNKNOWN
PotionEffectType: enum!  # 
    values: 
      - absorption
      - bad_omen
      - blindness
      - conduit_power
      - darkness
      - dolphins_grace
      - fire_resistance
      - glowing
      - haste
      - health_boost
      - hero_of_the_village
      - hunger
      - infested
      - instant_damage
      - instant_health
      - invisibility
      - jump_boost
      - levitation
      - luck
      - mining_fatigue
      - nausea
      - night_vision
      - oozing
      - poison
      - raid_omen
      - regeneration
      - resistance
      - saturation
      - slow_falling
      - slowness
      - speed
      - strength
      - trial_omen
      - unluck
      - water_breathing
      - weakness
      - weaving
      - wind_charged
      - wither
PotionType: enum!  # 
    values: 
      - awkward
      - fire_resistance
      - harming
      - healing
      - infested
      - invisibility
      - leaping
      - long_fire_resistance
      - long_invisibility
      - long_leaping
      - long_night_vision
      - long_poison
      - long_regeneration
      - long_slow_falling
      - long_slowness
      - long_strength
      - long_swiftness
      - long_turtle_master
      - long_water_breathing
      - long_weakness
      - luck
      - mundane
      - night_vision
      - oozing
      - poison
      - regeneration
      - slow_falling
      - slowness
      - strength
      - strong_harming
      - strong_healing
      - strong_leaping
      - strong_poison
      - strong_regeneration
      - strong_slowness
      - strong_strength
      - strong_swiftness
      - strong_turtle_master
      - swiftness
      - thick
      - turtle_master
      - water
      - water_breathing
      - weakness
      - weaving
      - wind_charged
Rabbit: enum!  # 
    values: 
      - RABBIT
Rabbit.Type: enum?  # TODO
    values: 
      - BLACK
      - BLACK_AND_WHITE
      - BROWN
      - GOLD
      - SALT_AND_PEPPER
      - THE_KILLER_BUNNY
      - WHITE
Slime: enum!  # 
    values: 
      - MAGMA_CUBE
      - SLIME
Sound: enum!  # 
SpectralArrow: enum!  # 
    values: 
      - SPECTRAL_ARROW
ThrowableProjectile: enum!  # 
    values: 
      - EGG
      - ENDER_PEARL
      - EXPERIENCE_BOTTLE
      - LINGERING_POTION
      - SNOWBALL
      - SPLASH_POTION
      - TRIDENT
ThrownPotion: enum!  # 
    values: 
      - LINGERING_POTION
      - SPLASH_POTION
TNTPrimed: enum!  # 
    values: 
      - TNT
Trident: enum!  # 
    values: 
      - TRIDENT
TrimMaterial: enum!  # 
    values: 
      - amethyst
      - copper
      - diamond
      - emerald
      - gold
      - iron
      - lapis
      - netherite
      - quartz
      - redstone
      - resin
TrimPattern: enum!  # 
    values: 
      - bolt
      - coast
      - dune
      - eye
      - flow
      - host
      - raiser
      - rib
      - sentry
      - shaper
      - silence
      - snout
      - spire
      - tide
      - vex
      - ward
      - wayfinder
      - wild
WitherSkull: enum!  # 
    values: 
      - WITHER_SKULL
Wolf: enum!  # 
    values: 
      - WOLF
BlockData: BlockDataData!  # 
Component: string!  # 
ConditionList: Condition{}?  # A list of conditions
ConditionListWrapper: ConditionList!  # TODO
Duration: number!  # 
EffectList: Effect{}?  # A list of effects
Expression: string | number!  # A mathematical expression or a number\nself_metadataName will evaluate to that metadata stored in the user\nother_metadataName will evaluate to that metadata stored in the user
ExpressiveMessage: string!  # Text that can have an expression in it with ${expression}
InventorySlot: EquipmentSlot | integer!  # 
ItemStack: ItemStackData!  # 
LoreData: string[]!  # 
PlusUltraSkillsContainer: SkillsContainer!  # TODO
RangeData: string!  # 
SkillsContainer: SkillData{}?  # TODO
Song: string!  # 
